<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>
<title></title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" type="text/css" href="../css/android.css">
</head><body>

<div class="subtitle"><h1>Topic 1 - Introduction to Kotlin</h1></div><hr>
<h2>What is Kotlin?</h2>
<ul>
<li>A statically-typed,
object-oriented and functional programming language developed
by <a href="http://www.jetbrains.com/">JetBrains</a> - developers of the
IntelliJ IDE which Android Studio is based on</li>
<li>Compiles to Java bytecode, therefore compatible with the Java
Virtual Machine</li>
<li>Because of this,
Kotlin code can be mixed with Java code in one application</li>
<li>Main site: <a href="http://www.kotlinlang.org/">here</a></li>
<li><em>Recommended as the preferred language to develop Android apps</em>, so we will start the module with a look at the basics of Kotlin before beginning Android development</li>
</ul>
<hr><h2>Some Kotlin features</h2>
<ul>
<li><em>Null safety</em>: language features to help guard against the
dreaded NullPointerException!</li>
<li><em>Type inference</em>: type of variables can be inferred by what they
are initialised to, so you don't need to explicitly declare the data type</li>
<li><em>Lambda functions</em>: anonymous functions which can be passed as
arguments to other functions (similar to arrow functions in JavaScript)</li>
<li><em>Data classes</em>: concisely create classes which represent data and
do not need methods</li>
<li><em>Extension functions</em>: add a single function (method) to an
existing class without needing to subclass it</li>
<li><em>Coroutines</em>: a lightweight approach to multi-tasking.
producing code which is easier to follow compared to threads</li>
</ul>
<hr><h2>Hello World in Kotlin</h2>
<ul>
<li>Here is Hello World in Kotlin:
<pre>fun main (args: Array&lt;String&gt;) {
    println("Hello World!")
}
</pre>
</li>
<li>Note that in Kotlin, <strong>we do not need to create a class</strong>;
we can use just functions (similar to C++)</li>
<li>We have a main function, similar to the main method in Java</li>
<li><strong>fun</strong> is the keyword for a function, and <em>println()</em>
prints to the console, just like <em>System.out.println()</em> in Java</li>
<li>Note the different parameter syntax: main() has one parameter,
<em>args</em>, which is an <em>Array</em> of <em>String</em>s (representing
the command-line arguments, as in Java)</li>
<li>Note also that Kotlin does not use semicolons (you can use them, but
it is not recommended as it is unnecessary)</li>
</ul>
<hr><h2>Variables example</h2>
<ul>
<li>This example shows some aspects of how variables work in Kotlin:
<pre>fun main (args: Array&lt;String&gt;) {
    // Declare a as an Int. "val" means it is immutable (cannot be changed)
    val a: Int = 3

    // Type inference: "b" is an Int because it is initialised to an Int
    val b = 4
    
    // "c" is a "var", which means it can be changed
    var c = 5    

    // increase "c" by one
    c++

    // this would give a compiler error as "b" is immutable
    // b++

    // this would also give a compiler error as "c" is implicitly an Int
    //c = "A String"

    // Some other data types
    val d = 12345678L // Long
    val pi = 3.141592654 // Double
    val f = 1.23f // Float
    val str = "Hello" // String


    // Print them out. Note how we can embed variables in a string
    // by preceding them with '$'
    println("a is $a, b is $b, c is $c, d is $d, f is $f, pi is $pi, str is $str")
}
</pre>
</li>
<li>Note how we use <em>val</em> for immutable (unchanging) variables,
and <em>var</em> for mutable variables (those which can change)</li>
<li>Note how the type of a variable can be <em>inferred</em> by what value
we assign it to, in all variables above apart from "a", we do not declare
the type</li>
<li>Nonetheless the variables <em>are</em> typed, we cannot place a String
in "c", for example</li>
<li>See <a href="http://kotlinlang.org/docs/reference/basic-types.html">here</a> for details on Kotlin data types</li>
</ul>
<hr><h2>Loops in Kotlin</h2>
<ul>
<li>The program below shows some examples of basic loops:
<pre>fun main (args: Array&lt;String&gt;) {
    // Count from 1 to 10
    for (i in 1..10) {
        println(i)
    }

    // Count from 1 to 9 ("until" discounts 10 itself)
    for(j in 1 until 10) {
        println(j)
    }

    // count from 1 to 9 in steps of 2
    for(k in 1..9 step 2) {
        println(k)
    }
}
</pre>
</li>
<li>Note the syntax <em>1..10</em>. This is called a 
<em>range expression</em>. It returns a Range object representing the
range of numbers 1 to 10.</li>
<li>Note also the difference between the first two examples; 
<em>until</em> is a function which
returns a Range from the initial number up to, but
<em>not including</em>, the final number
    <ul>
    <li>So the second loop will only count from 1 to 9</li>
    </ul>
</li>
<li>We also have the standard, Java-style <em>while</em> loop too</li>
<li>See <a href="http://kotlinlang.org/docs/reference/control-flow.html">
here</a> for full documentation on loops</li>
</ul>
<hr><h2>Conditional statements in Kotlin</h2>
<ul>
<li>The program below shows some examples of conditional statements in
Kotlin:
<pre>fun main (args: Array&lt;String&gt;) {
    println("Enter your name:")
    val n = readLine()
    if (n == "Linus Torvalds") {
        println("You invented Linux")
    } else {
        println("You didn't invent Linux")
    }

    println("Enter your grade:")
    val grade = readLine()
    when(grade) {
        "A" -&gt; println("First")
        "B" -&gt; println("2.1")
        "C" -&gt; println("2.2")
        "D" -&gt; println("Third")
        "F" -&gt; { 
            println("Fail")
            println("Please resit in the summer.") 
        }
        else -&gt; println("Invalid grade $grade.")
    }
}
</pre>
</li>
<li>Note how if/else is similar to Java</li>
<li>The <em>when</em> statement is not in Java; it is similar to 
<em>switch</em> but has some interesting additional features, see next
slide</li>
<li>Note the use of <em>else</em> inside <em>when</em> to handle unmatched
conditions (e.g. here, if the grade is not A, B, C, D or F)</li>
</ul>
<hr><h2>Conditional expressions</h2>
<ul>
<li>An important difference in Kotlin compared to java is that conditionals
can be used as <em>expressions</em>, i.e. they can return a value
which can be assigned to a variable</li>
<li>eg. 
<pre>fun main (args: Array&lt;String&gt;) {
    println("Enter your name:")
    val n = readLine()

    // "msg" contains the result of the if statement
    val msg = if (n=="Linus Torvalds") "You invented Linux" else "You didn't invent Linux"
    println(msg)

    println("Enter your grade:")
    val grade = readLine()

    // "degree" contains the result of the when statement
    val degree = when(grade) {
        "A" -&gt; "First" // Return "First" when grade is "A"
        "B" -&gt; "2.1" // Return "2.1" when grade is "B"
        "C" -&gt; "2.2"
        "D" -&gt; "Third"
        "F" -&gt; "Fail"
        else -&gt; "Invalid grade $grade."
    }
    println("Degree awarded: $degree.")
}
</pre>
</li>
<li>Note in this example how we store the result of the <em>if</em>
statement in the variable <em>msg</em>
    <ul>
    <li>...so that <em>msg</em> wil contain either <em>You invented Linux</em>
    or <em>You didn't invent Linux</em>, depending on the name typed in</li>
    </ul>
</li>
<li>Also notice how the <em>when</em> statement similarly returns a value,
i.e. "First" when the grade is "A", "2.1" when the grade is "B", etc. </li>
</ul>
<hr><h2>Basic arrays, including for-in and if-in</h2>
<ul>
<li>Arrays are available in Kotlin, like most other languages</li>
<li>THe <em>in</em> keyword in Kotlin allows us to do foreach-style loops
with arrays and easily work out if a value is in an array</li>
<li>
<pre>fun main (args: Array&lt;String&gt;) {
    val langs = arrayOf("Python", "Java", "JavaScript", "PHP", "Kotlin")
    println("Languages you are learning at university:")
    for(curLang in langs) {
        println(curLang)
    }
    println("Please enter a programming language:")
    val lang = readLine()
    val msg = if(lang in langs) "learning" else "not learning"
    println("You are $msg $lang at university.")
}
</pre>
</li>
<li>Note the use of the if statement as an expression again
(<em>if(lang in langs)...</em>)</li>
<li>Next time we will cover some additional features of arrays, and
lists</li>
</ul>
<hr><h2>Nullability</h2>
<ul>
<li>One of the really useful features of Kotlin is <em>null safety</em></li>
<li>With Kotlin, you can declare a variable to either be nullable or
non-nullable</li>
<li>Non-nullable variables will produce a <strong>compiler error</strong>
if you attempt to store 'null' in them</li>
<li>Thus we can guard against the dreaded NullPointerException</li>
</ul>
<hr><h2>Non-nullable variables</h2>
<ul>
<li>By default, given data types (String, etc.)
are <em>non-nullable</em></li>`
<li>So this code will not compile, beacuse we declare <em>s</em> as a
non-nullable String and attempt to assign null to it
<pre>fun main (args: Array&lt;String&gt;) {
    var s: String = null
    println(s.length);
}
</pre>
</li>
<li>This is a better result than Java, in which the program would compile, but
crash with a NullPointerException when we try to access the length...</li>
</ul>
<hr><h2>Nullable variables</h2>
<ul>
<li>What about cases where we want the variable to be nullable?</li>
<li>For example, a collection of data which doesn't exist until we open 
a file and read it in from the file</li>
<li>In this case, we <em>explicitly declare the variable as nullable</em>
by adding a question-mark <em>?</em> to the data type</li>
<li>So, will this code successfully compile?
<pre>fun main (args: Array&lt;String&gt;) {
    var s: String? = null
    println(s.length);
}
</pre>
</li>
</ul>
<hr><h2>The safe-access operator</h2>
<ul>
<li>The answer is <em>no</em>, because even though we declared <em>s</em>
as a nullable string, we then try to access the length of a String object
which is null</li>
<li>In Java this type of operation would throw a NullPointerException</li>
<li>Kotlin's null-safety forces you to deal with this using the 
safe-access operator, <em>?.</em></li>
<li>Here is the previous example, rewritten to use the safe-access operator:
<pre>fun main (args: Array&lt;String&gt;) {
    var s: String? = null
    println(s?.length);
}
</pre>
</li>
<li>Here, due to the safe-access operator, we will only access the length
if "s" is not null</li>
</ul>
<hr><h2>A practical example, and introducing Elvis</h2>
<ul>
<li>The previous example was to illustrate the nullable concept only, and 
obviously does not do anything interesting</li>
<li>This example shows a more practical use of the safe-access operator;
note that <em>readLine()</em> returns a nullable String (<em>String?</em>):
<pre>fun main (args: Array&lt;String&gt;) {
    println("Please enter a number:")
    val str1 = readLine() // this might return null, e.g. if we are in a non-console environment

    // Elvis: Set a EITHER to the return value of toInt(), or 0 if str1 is null
    val a = str1?.toInt() ?: 0

    println("Please enter another number:")
    val str2 = readLine() // this might return null

    // Elvis: Set b EITHER to the return value of toInt(), or 0 if str2 is null
    val b = str2?.toInt() ?: 0

    // Note how we can embed full expressions inside strings with $
    println("The sum of the two numbers is ${a+b}");
}
</pre>
</li>
<li>This example reads in two numbers as (nullable) strings, tries to
convert them to integers with the <em>toInt()</em> method, 
and prints the sum</li>
<li>Note how the safe-access operator is used to call <em>toInt()</em>
in case <em>str1</em> is null</li>
<li>What of the new operator, <em>?:</em> though?</li>
<li>This is known as the <em>Elvis operator</em> (why? apparently because it's 
the emoticon for Elvis Presley)</li>
<li>In cases where we're trying to
call a method (or access an attribute) of a nullable with the safe-access
operator, the Elvis operator allows us to set a value for a variable
normally obtained from the return value of the method 
in cases where the nullable is null</li> 
<li>So if either string (str1 or str2) is null, the corresponding Int
(a or b) will be assigned the value 0 rather than the return value of
<em>toInt()</em></li>
<li>More on nullability <a href="http://kotlinlang.org/docs/reference/null-safety.html">here</a>.</li>
</ul>
<hr><h2>Functions in Kotlin</h2>
<ul>
<li>The following example shows the use of functions in Kotlin, 
including parameters and return types:
<pre>
fun printString(s: String, nTimes: Int)
    for(i in 1..nTimes) {
        print(s)
    }
    print("\n")
}

fun cube(number: Double) : Double {
    return number * number * number
}

fun main (args: Array&lt;String&gt;) {
    printString("*", 3)    
    printString("#", 4)    
    printString("!", 5)    
    println("The cube of 3 is: ${cube(3.0)}")
}
</pre>
</li>
<li>Note the syntax for parameters 
    <ul><li><em>(s: String, nTimes: Int)</em></li></ul>
 and return types 
    <ul><li>fun cube(number: Double) : <em>Double</em>)</li></ul>
</li>
<li>Note also how we can put function calls in quotes using $, and {} to
contain the expression
    <ul><li> println("The cube of 3 is: <em>${cube(3.0)}</em>")</li></ul>
</li>
</ul>
<hr><h2>Classes and Objects in Kotlin</h2>
<ul>
<li>Like Java, you can do OO programming in Kotlin</li>
<li>Classes and objects work similarly to Java, but there are some differences
and enhancements</li>
<li>Here is a basic example (the famous Cat class...)
<pre>class Cat (n: String, a: Int, w: Int) {

    // Attributes
    val name: String
    var age: Int
    var weight: Int
    
    // Init block, for performing tasks on creation of the object
    init {
        name = n
        age = a
        weight = w
    }

    fun walk() {
        this.weight--
    }

    fun display() {
        println("Name: $name Age: $age Weight: $weight")
    }
}

fun main (args: Array&lt;String&gt;) {
    val felix = Cat("Felix", 10, 10)
    val tom = Cat("Tom", 5, 5)
    felix.walk()
    tom.walk()
    felix.display()
    tom.display()
}
</pre>
</li>
<li>Note how we <strong>place the constructor parameters (name, age and
weight) immediately after the class name</strong> - this is different to
Java in which we create a constructor function inside the class body</li>
<li>Note also the <strong>init block</strong>. This contains code we want
to run when the object is first created. Here, we simply set the 
attributes equal to the constructor parameters</li>
<li>The methods walk() and display() are similar to Java.</li>
</ul>
<hr><h2>Making our class more concise - automatically setting 
constructor parameters equal to class attributes</h2>
<ul>
<li>This version of the previous example is more concise:
<pre>class Cat (val name: String, var age: Int, var weight: Int) {

    fun walk() {
        this.weight--
    }

    fun display() {
        println("Name: $name Age: $age Weight: $weight")
    }
}


fun main (args: Array&lt;String&gt;) {
    val felix = Cat("Felix", 10, 10)
    val tom = Cat("Tom", 5, 5)
    felix.walk()
    tom.walk()
    felix.display()
    tom.display()
}
</pre>
</li>
<li>Note how we <em>specify either val or var before each 
constructor parameter</em></li>
<li>
This <strong>automatically makes each parameter an attribute of the class
</strong></li>
<li><em>val</em>s will be immutable, <em>var</em>s will be mutable</li>
<li>Thus, unlike the previous version, we do not have to declare the
attributes inside the class, or use an init block</li>
</ul>
<hr><h2>Data classes - concisely representing complex data structures
</h2>
<ul>
<li>In many cases, we need to create classes which represent a complex data
structure, but do not need methods</li>
<li>A good example would be a <em>Point</em> class, to represent a 
2D point (with x and y coordinates)</li>
<li>In Java, you could do this (note how x and y are public, to avoid
the need for getters and setters; an implementation which wanted to
make x and y immutable would need to make them private and add getter methods):
<pre>public class Point {
    public int x, y;

    public Point (int x, int y) {
         this.x = x;
         this.y = y;
    }
}
</pre>
</li>
<li>However, having to create a constructor to initialise the attributes
to the constructor parameters is a pain</li>
<li>In Kotlin, in an extension of the previous example,
you can create a Point class with just
<strong>one line of code</strong>:
<pre>data class Point(val x:Int, val y: Int)</pre>
</li>
<li>That is it! This will create a Point class, with a two argument
constructor (x and y), and two immutable (because of <em>val</em>) 
attributes, also x and y</li>
<li>This could be used in a main() function as follows:
<pre>data class Point(val x:Int, val y: Int)

fun main (args: Array&lt;String&gt;) {
    val p = Point(0, 5)
    val p2 = Point(5, 2)
    println("${p.x} ${p.y}")
    println("${p2.x} ${p2.y}")
}
</pre>
</li>
<li>Much more concise code!</li>
</ul>
<hr><h2>Introducing some more Kotlin collections</h2>
<ul>
<li>Last time we looked at how to create simple <em>arrays</em></li>
<li>However, we can also use Java-style <em>collections</em> in Kotlin, e.g. List, HashMap</li>
<li>The syntax and initialisation methods are, however, a little different</li>
<li>In Kotlin, collections divide into <em>mutable</em> collections (those that can be altered) and
<em>immutable</em> collections (those which cannot, which are more efficient in cases where the data in
the collection never changes)</li>
</ul>
<hr><h2>The List</h2>
<ul>
<li>This example shows basic use of a List:
<pre>fun main(args: Array&lt;String&gt;) {
    val peopleList = listOf("Mark Cranshaw", "Rob Cooper", "Al Monger", "Mark Udall", "Margaret Jones")
    for(p in peopleList) {
        println("$p was formerly a lecturer at Solent University.")
    }
}
</pre>
We create a list of former lecturers at the university and use a <em>for/in</em> loop
to iterate through each</li>
<li>Note that <em>listOf()</em> returns an <em>immutable</em> list (a list of type List);
this cannot be altered (e.g. it does not have an <em>add()</em> method)</li>
</ul>
<hr><h2>Creating a Mutable List</h2>
<ul>
<li>This example shows basic use of a mutable List:
<pre>fun main(args: Array&lt;String&gt;) {
    val peopleList = <em>mutableListOf</em>("Mark Cranshaw", "Rob Cooper", "Al Monger", "Mark Udall", "Margaret Jones")
    <em>peopleList.add("Roger Forster")</em>
    for(p in peopleList) {
        println("$p was formerly a lecturer at Solent University.")
    }
}
</pre>
Note how we use <em>mutableListOf</em></li>
<li>This returns an object of type <em>MutableList</em>, which has an <em>add()</em> method</li>
<li>Also note that <em>peopleList</em> is <em>val</em>, not <em>var</em>, even though it's a MutableList
    <ul>
    <li>Even though we add new data to the list, the actual object reference <em>peopleList</em>
    (which represents the memory address of the list) does <em>not</em> change</li>
    <li>Hence we can use a <em>val</em>ue for this example</li>
    </ul>
</li>
<li>We can create an empty list by omitting the arguments, e.g:
<pre>val peopleList = mutableListOf<em>&lt;String&gt;</em>()</pre>
</li>
</ul>
<hr><h2>More on Functions in Kotlin</h2>
<ul>
<li>In Kotlin, functions can be <em>stored in variables</em> and
<em>passed as arguments to other functions</em>
    <ul>
    <li>In this respect, Kotlin is similar to JavaScript</li>
    </ul>
</li>
<li>This property of functions makes them <em>first class</em>
(see <a href="https://kotlinlang.org/docs/reference/lambdas.html">the Kotlin documentation</a>)</li>
<li>This can allow for some powerful programming techniques,
e.g. operating on all members of an array or list using a function,
allowing us to adopt a functional programming style</li>
<li>..or, allowing us to pass a function as a <em>callback</em> to another function, helping
this function become more loosely-coupled</li>
</ul>
<hr><h2>Anonymous Functions</h2>
<ul>
<li>An <em>anonymous function</em> is a function with no declared name after the <em>fun</em> keyword</li>
<li>Anonymous functions can be passed in as 
arguments to another function, or referred to via variables</li>
<li>Here is a basic example of an anonymous function, referred to by the variable <em>funcReference</em> here:
<pre>fun main(args: Array&lt;String&gt;) {
    val funcReference = fun(i: Int): Int { return i*i*i }
    println(funcReference(3))
    val secondRef = funcReference
    println(secondRef(4))
}
</pre>
</li>
<li>Note how we set <em>funcReference</em> equal to a function which has one Int parameter, returns Int and
calculates and returns the cube of the number</li>
<li><em>funcReference</em> is a reference to this anonymous function</li>
<li>We can use this reference to call the function</li>
<li>Notice how we can also set up a <em>second</em> reference (<em>secondRef</em> here)
to the function, and use that to call it</li>
</ul>
<hr><h2>Passing functions as arguments to other functions</h2>
<ul>
<li>In Kotlin, we can <em>pass functions as arguments to other functions</em></li>
<li>The parameter type for a function passed into another is:
<pre>(ParamType1, ParamType2, ParamType3...) -&gt; returnType</pre>
where <em>ParamType1, ParamType2, ParamType3</em> etc. are the parameter types for the 
function being passed in, and <em>returnType</em> is the return type of that function</li>
<li>This is probably better explained via example, so here is one:
<pre>fun main(args: Array&lt;String&gt;) {
    val cubeFunction = fun(i: Int): Int { return i*i*i }
    execFunction(cubeFunction)
}

fun execFunction ( f: (Int) -&gt; Int) {
    println(f(3)) // call the function passed in with an argument of 3, i.e. the cube of 3 will be calculated
}
</pre>
Note that we pass <em>cubeFunction</em> in as an argument to <em>execFunction</em></li>
<li>The corresponding data type of the parameter, <em>f</em>, is <em>(Int) -&gt; Int</em>,
to indicate that the function being passed in takes one Int and returns an Int</li>
<li>If the function being passed in returns nothing, we specify <em>Unit</em> as the return type, e.g:
<pre>fun main(args: Array&lt;String&gt;) {
    val printStars = fun(i: Int){ 
        for(count in 1..i) {
            print("*")
        }
        print("\n")
    }
    execFunction(printStars)
}

fun execFunction ( f: (Int) -&gt; <em>Unit</em>) {
    f(3)// call the function passed in with an argument of 3, i.e. three stars will be printed
}
</pre>
This time we pass in a function which prints a given number of stars, but does not return
anything, hence specifying <em>Unit</em> as the return type of the function passed into <em>execFunction</em>
</li>
</ul>
<hr><h2>Lambda functions</h2>
<ul>
<li><em>Lambda</em> functions are similar to ordinary anonymous functions but use a special, concise syntax</li>
<li>Here is the first example rewritten to use a lambda function:
<pre>fun main(args: Array&lt;String&gt;) {
    val cubeLambda: (Int) -&gt; Int =  { i -&gt; return i*i*i }
    println(cubeLambda(3))
}
</pre>
</li>
<li>Note how we write a lambda: we enclose the whole function (the parameters as well as the function body)
in braces { }, and separate the parameters and the function body with the <em>-&gt;</em> token</li>
<li>Note how we have to specify the <em>type</em> of the lambda:
<pre>val cubeLambda: (Int) -&gt; Int</pre>
This is because we do not specify the parameter types in the lambda, therefore we have to specify the type of
the variable holding it</li>
<li>Note how in our case, the lambda only has one statement (<em>return i*i*i</em>), but they can
actually have multiple statements, one statement per line; e.g.
<pre>val someLambda: (Int) -&gt; Int = { parameter-&gt;
    statement1
    statement2
    return someValue
}
</pre>
</li>
<li>See <a href="https://kotlinlang.org/docs/reference/lambdas.html">the Kotlin documentation</a> for more details</li>
</ul>
<hr><h2>Making the lambda more concise - I</h2>
<ul>
<li>We can make the previous version more concise</li>
<li>With lambdas, <em>the value declared in the last line is always automatically returned</em></li>
<li>So the code below will also have the same effect as the previous example:
<pre>fun main(args: Array&lt;String&gt;) {
    val conciseCubeLambda: (Int) -&gt; Int =  { i -&gt; i*i*i }
    println(conciseCubeLambda(3))
}
</pre>
Because the last statement of the lambda is always returned, and that last statement here is <em>i*i*i</em>,
it follows that <em>i*i*i</em> will be returned from the lambda in this example, and the desired effect of
returning the cube will be achieved</li>
</ul>
<hr><h2>Making the lambda more concise - II - the implicit "it"</h2>
<ul>
<li>It doesn't stop there!</li>
<li>In cases in which a lambda has just <em>one</em> parameter - a common situation - we can refer to
that one parameter implicitly using the keyword <em>it</em></li>
<li>Thus, we can rewrite the cube example as follows:
<pre>fun main(args: Array&lt;String&gt;) {
    val cubeLambdaWithIt: (Int) -&gt; Int =  { it*it*it }
    println(cubeLambdaWithIt(3))
}
</pre>
Because the <em>it</em> parameter always corresponds to a single argument passed in (3 in this example),
and because the value of last statement of a lambda is always returned, it follows that this example
will also calculate the cube of the argument passed into the lambda</li>
</ul>
<hr><h2>Real-world use of lambdas</h2>
<ul>
<li>A very common real-world use of lambdas is to write code in a <em>functional</em> style</li>
<li>A typical pattern in functional code is to <em>apply a given function to all members of an array,
list or map</em></li>
<li>This leads to more readable, intuitive code with the details of looping through the collection
hidden away</li>
<li>Collections (lists, maps) have a range of functions (methods) which apply a lamda to some or all members of
the collection</li>
<li>The simplest is <em>forEach()</em>, which applies a lambda to all members of a collection:
<pre>fun main(args: Array&lt;String&gt;) {
    val peopleList = listOf("Mark Cranshaw", "Rob Cooper", "Al Monger", "Mark Udall", "Margaret Jones")
    peopleList.forEach { person -&gt; println(person) }
}
</pre>
</li>
<li>Note how the <em>forEach()</em> method of the list takes a lambda as an argument</li>
<li>The lambda will be applied to all members of <em>peopleList</em>, with each person in turn being passed into
the lambda as the <em>person</em> parameter</li>
<li>The result, therefore, will be that each person will be printed</li>
<li>Note also how we can omit the parentheses () when passing in a lambda as the first argument to a function</li>
</ul>
<hr><h2>Question</h2>
<ul>
<li>How can we make
<pre>peopleList.forEach { person -&gt; println(person) }</pre>
more concise?</li>
<li>Answer will be given out in class!</li>
</ul>
<h2>Further reading</h2>
<p>I have prepared some notes on additional basic Kotlin topics, including inheritance and map data structures. We may be able to cover these at the start of the lab session. If not, <a href='topic1a.html'>please read the notes here</a>.</p>
</body></html>
