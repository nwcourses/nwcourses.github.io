<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>
<title>ViewModel and LiveData</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" type="text/css" href="../css/android.css">
</head><body>

<div class='titlebox'>
<h1>Mobile Application Development - Topic 10</h1>
<h1>ViewModel and LiveData</h1>
</div>
<p>Today we will look at the Android components <code>ViewModel</code> and <code>LiveData</code> and how they can lead to cleaner, more maintainable code and easier synchronisation of the underlying data of the application with the UI.</p>
<h2>The concept of LiveData</h2>
<p>Let's consider an extended version of our Room application from week 7, which lists all the songs currently in the database in a <code>TextView</code> underneath the <code>EditText</code>s and buttons. It would be nice if the UI could <em>automatically update</em> whenever the underlying data in the database changes. This is shown below: 
<br />
<img src="../images/livedata1.png" alt="Database app using LiveData" />
<br />
The user can add songs via the UI. Also, the list of songs in the <code>TextView</code> below the form updates when a new song is added (you can see that we've just added Oasis and the song has appeared on the <code>TextView</code>). We could do this manually if we wanted, but it's much easier to automatically update the list of songs using the concept of <code>LiveData</code> instead. Using <code>LiveData</code> for our data allows us to auto-update the UI whenever it changes. It can be <em>observed</em> by another part of the application. We observe <code>LiveData</code> in this way with an <code>Observer</code> object. The <code>Observer</code> runs a specified lambda function each time the data changes; this lambda receives the updated data as a parameter. So, in the <code>Observer</code>'s lambda, we can take the updated data and use it to update the UI appropriately.</p>

<h3>Example</h3>
<p>It's easy to update a DAO to return <code>LiveData</code>.We simply update our DAO so that the search methods return <code>LiveData</code> of the appropriate type. So, in a student records app, we might change:
<pre>
@Query("SELECT * FROM students")
fun getAllStudents(): List&lt;Student&gt;
</pre>
to:
<pre>
@Query("SELECT * FROM students")
fun getAllStudents(): LiveData&lt;List&lt;Student&gt;&gt;
</pre>
In other words, the <code>getAllStudents()</code> method is now returning <code>LiveData</code> consisting of a list of students.</p>
<h3>The observer</h3>
<p>We can then <em>observe</em> the data to watch for changes, for example from our activity. For
example, we could add this code to our <code>MainActivity</code>'s <code>onCreate()</code> just after initialising the database:
<pre>
db.studentDao().getAllStudents().observe(this, Observer {
    findViewById&lt;TextView&gt;(R.id.tvResults).text = it.joinToString("\n");
});
</pre>
As you can hopefully see, <code>db.studentDao().getAllStudents()</code> calls the DAO method <code>getAllStudents()</code> we referenced above, which returns the <code>LiveData</code>. <code>LiveData</code> has an <code>observe()</code> method which is used to attach an <code>Observer</code> to it, to watch for changes. Note how when we are creating the <code>Observer</code>, we specify a lambda function. This runs whenever the data updates, and receives the updated data as a single parameter (so it can be referenced using <code>it</code>). We convert the received list to a string using the <code>joinToString()</code> method, which will combine each member of the list into one string using the given separator (a new line, i.e. <code>\n</code>, here). This string will then be used to update the given text view.</p>

<h2>The ViewModel</h2>

<p><code>LiveData</code> is frequently used with a <code>ViewModel</code>. What is this?</p>
<p> A common aim in object-oriented programming is to make all classes as concise, and focused on one thing, as possible. This makes the classes smaller and easier to understand, and thus maintain. A small, tightly-focused class (focused on one particular thing) has high <em>cohesion</em>. Achieving high cohesion is well-known good software engineering practice.</p>
<p>However, in Android development, if we are not careful our activities can quickly become very large and "bloated", and end up containing a lot of variables hoding the application's data and methods to manipulate that data. Thus they have low cohesion, as they are trying to do too many things. It would be better to try and <em>separate out the activity from its data</em> so that the activity only manages core operations (such as lifecycle events - <code>onCreate()</code>, <code>onResume()</code> etc) and have another class which stores the data.</p>
<p>Luckily we can do this quite easily with Android thanks to the use of a <code>ViewModel</code> (see <a href="https://developer.android.com/topic/libraries/arcstudentecture/viewmodel">the Android documentation</a>). What is a <code>ViewModel</code>? It's an object which holds <em>the data which needs to be displayed by the application</em>, and is responsible for "preparing data for the UI" (<a href="https://developer.android.com/topic/libraries/arcstudentecture/viewmodel#implement">Android docs</a>), as part of the Model-View-ViewModel (MVVM) arcstudentecture. In this arcstudentecture:
    <ul>
    <li>the <em>Model</em> represents the classes directly communicating with the database, such as the DAO;</li>
    <li>the <em>View</em> represents the UI classes of your application, for example activities, fragments, etc.</li>
    </ul>
In other words, a <code>ViewModel</code> holds raw data from a data source (the <em>Model</em>) and processes it into a form suitable for display, at which point it is sent to the UI (<em>View</em>).</p>
<p>As well as enabling higher cohesion, using a <code>ViewModel</code> in Android has the advantage that it is <em>persistent throughout the lifetime of the application</em>, even if other components such as activities are destroyed. Remember from previously that an activity is destroyed and re-created when it's rotated. This can cause difficulties if you want to preserve data; by default, all data stored in an activity will be destroyed when it's rotated, as it belongs to a particular instance of the activity. If you use a <code>ViewModel</code> instead, the data will be preserved and will be accessible by the activity when it is re-created.</p>
<p><img src="../images/viewmodel.png" alt="ViewModel" /></p>
<h3>Creating a ViewModel</h3>

<p>Creating a <code>ViewModel</code> is quite easy. We need to ensure the <code>lifecycle-runtime-ktx</code> Jetpack library into our <code>build.gradle</code> dependencies, e.g: <pre>implementation 'androidx.lifecycle:lifecycle-runtime-ktx:2.5.1'</pre>
and create a class inheriting from <code>androidx.lifecycle.ViewModel</code>.
<pre>
package com.example.viewmodel1

import androidx.lifecycle.ViewModel

class TestViewModel : ViewModel() {
    var firstName = ""
    var lastName = ""
}
</pre>
This is creating a simple <code>ViewModel</code> to store someone's first and last name.</p>

<h3>Using the ViewModel from an Activity</h3>

<p>We then need to initialise the <code>ViewModel</code> from an <code>Activity</code>. The example below shows how to do this:

<pre>
class MainActivity :AppCompatActivity() {

    val viewModel : TestViewModel by viewModels()

    // ... class continues ...
</pre>

Note how we declare a variable <code>viewModel</code> within our activity, of class <code>TestViewModel</code> (our <code>ViewModel</code> class shown above).</p>
<h4>Updating the ViewModel and the UI</h4>
<p>Later on, at any point, we can update the <code>ViewModel</code>'s data, e.g.
<pre>
viewModel.apply {
    firstName = "Fred"
    lastName = "Jones"
}
</pre>
and we can also update the UI with the contents of the <code>ViewModel</code>, e.g.:
<pre>
findViewById&lt;TextView&gt;(R.id.info).text = "${viewModel.firstName} ${viewModel.lastName}"
</pre>
</p>
<p>Clearly this is a very simple example, but for more complex apps, which need to store and display large amounts of data, a <code>ViewModel</code> makes sense. Furthermore, even in this simple example, a <code>ViewModel</code> can be advantageous, as the data remains in memory even when the device is rotated. If we simply stored the first name and last name in the activity, it would be lost when the device is rotated, as the activity (and all its data) is destroyed and re-created. The <code>ViewModel</code> by contrast is stored independently to the activity in memory.</p>

<h3>ViewModel dependencies</h3>
<p>Ensure these dependencies are added to your <code>build.gradle</code>:
<pre>
implementation "androidx.activity:activity-ktx:1.5.1"
</pre>
This needed for the delegate-based initialisation of the <code>ViewModel</code>.</p> 
<h2>Using LiveData with ViewModel</h2>

<p>Commonly, <code>LiveData</code> and <code>ViewModel</code> are used together. A <code>ViewModel</code> can hold <code>LiveData</code> which is observed by an <code>Observer</code>. When the data changes, the <code>Observer</code> callback receives the altered data and uses it to update the UI.</p>

<p>Here is an example of an application which does this.
First the <code>ViewModel</code>, which contains a list of <code>Student</code> objects and some <code>LiveData</code> wrapping those <code>Student</code>s:

<pre>
package com.example.viewmodel2

import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.ViewModel

data class Student(val id:Int = 0, val name: String = "", val course: String = "") {
    override fun toString(): String {
        return "Student ID $id: name $name, course $course"
    }
}

class TestViewModel : ViewModel() {
    val students = mutableListOf&lt;Student&gt;()
    val studentsLive = MutableLiveData&lt;MutableList&lt;Student&gt;&gt;()

    fun addStudent(s: Student) {
        students.add(s)

        // must reset the live data after changing the underlying data, you can't link the live data with underlying data on startup and expect it to "just work"
        studentsLive.value = students
    }
}

</pre>
and the activity, which allows the user to enter a student, adds the student to the view model, observes changes in the student list <code>LiveData</code> and updates the UI accordingly:
<pre>
package com.example.viewmodel2

import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import android.widget.Button
import android.widget.EditText
import android.widget.TextView
import androidx.activity.viewModels
import androidx.lifecycle.Observer

class MainActivity : AppCompatActivity() {

    val viewModel: TestViewModel by viewModels()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        // When the button is clicked, create a student object and add it to
        // the ViewModel.

        findViewById&lt;Button&gt;(R.id.btn1).setOnClickListener {
            viewModel.apply {
                val s = Student(
                    findViewById&lt;EditText&gt;(R.id.etId.text.toString().toInt(),
                    findViewById&lt;EditText&gt;(R.id.etName).text.toString(),
                    findViewById&lt;EditText&gt;(R.id.etCourse).text.toString()
                )
                viewModel.addStudent(s)
            }
        }

        // Observe changes in the LiveData within the ViewModel. When the 
        // LiveData changes, update the TextView with the new data.
        viewModel.studentsLive.observe(this, Observer {
            // Map the array of students to an array of Strings containing the student details, by calling the toString() method of each student
            val studentDetails = it.map ( student -&gt; student.toString() )
            
            // Join the array of Strings into a single String and display it in the TextView
            findViewById&lt;TextView&gt;(R.id.tv1).text = studentDetails.joinToString("\n")
        })
    }
}

</pre>


Note how the <code>ViewModel</code> contains both a student list (<code>students</code>) and some <code>LiveData</code> associated with that list (<code>studentsLive</code>). Here we need to create the <code>LiveData</code> ourselves: note that it is <code>MutableLiveData</code> (<code>LiveData</code> that can be updated). In the addStudent()</code> method of the <code>ViewModel</code>, we add the student to the regular list (<code>students</code>) and then <em>update the <code>value</code> of the live data (<code>studentsLive</code>) to the list</em> so that the live data continuously "tracks" the list.</p>

<p>In the main activity, we add the student details to the <code>ViewModel</code> when a button is clicked, and set up an <code>Observer</code> to track changes in the <code>LiveData</code> so that the UI is updated with the current list of students whenever the list changes.</p>

<h2>Using LiveData and a ViewModel with Room</h2>

<p>The other thing we can do is to use both <code>LiveData</code> and a <code>ViewModel</code> together with Room. To do this you would return <code>LiveData</code> from the DAO (as above) and <em>store a reference to it in your <code>ViewModel</code></em>. Then, you can observe the data in the <code>ViewModel</code> with an <code>Observer</code>, as before.</p>
<p>Here is an example of a <code>ViewModel</code> set up to store <code>LiveData</code> from a Room database containing student records:
<pre>

package com.example.roomapp

import android.app.Application
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.LiveData

// We need to pass in the Application object
class StudentViewModel(app: Application): AndroidViewModel(app)  {
    // Get a reference to the database, using the Application object
    var db = StudentDatabase.getDatabase(app)
    var students : LiveData&lt;List&lt;Student&gt;&gt;

    // When we initialise the ViewModel, get the LiveData from the DAO
    // The variable 'students' will always contain the latest LiveData.
    init {
        students = db.studentDao().getAllStudents()
    }

    // Return the LiveData, so it can be observed, e.g. from the MainActivity
    fun getAllStudents(): LiveData&lt;List&lt;Student&gt;&gt; {
        return students
    }
}
</pre>
The <code>ViewModel</code> would then be setup from the <code>MainActivity</code> in the normal way:
<pre>
val viewModel : StudentViewModel by viewModels()
</pre>
and observed in the normal way by observing the <code>getAllStudents()</code> method of the <code>ViewModel</code>:
<pre>
viewModel.getAllStudents().observe(this, Observer {
    tvResults.text = it.joinToString("\n") // display data in 'tvResults', a TextView
})
</pre>
</p>
<h2>Exercises</h2>
<p>Before doing these exercises you will need to ensure that <em>Auto-rotate screen</em> is turned on in the Settings, to make sure that rotating the device triggers a destroy/recreation of the activity. To do this:
    <ul>
    <li>Obtain the settings by "dragging up" the phone's screen;</li>
    <li>Select "Settings";</li>
    <li>Select "Display";</li>
    <li>Ensure "Auto-rotate screen" is on.</li>
    </ul>
</p>
<h3>Questions</h3>
<ol>
<li><em>Basic LiveData:</em> Clone this project from GitHub:
<pre>https://github.com/nwcourses/RoomAppBasic.git</pre>
It's a very simple Room app which allows you to add songs to a database, similar to what you did previously. Modify the app so that the <code>getAllHits()</code> method of the DAO returns <code>LiveData</code> of a <code>List</code> of <code>Hit</code>s. In the main activity, add some code to observe changes in the <code>LiveData</code> and show the results in the <code>TextView</code> with an ID of <code>tvResults</code>, as shown in the example</li>
<li><em>Exploring ViewModel</em>: Clone this project from GitHub:
<pre>https://github.com/nwcourses/ViewModelStarter.git</pre>
This is a simple application which allows the user to enter a song and artist. When the button is clicked the song and artist is displayed in a <code>TextView</code> <em>and also saved in the <code>currentSong</code> attribute of the <code>Activity</code>.</em>
    <ul>    
    <li>First enter a song and artist in the <code>EditText</code> and note how it appears in the <code>TextView</code>.</li>
    <li>When you rotate the device, what happens?</li>
    <li>Try using <code>ViewModel</code> to preserve the details when the device rotates, following the example above. When the user enters the details, you need to save it in a <code>ViewModel</code>. Also, when the activity is first created (i.e. in <code>onCreate()</code>, you will need to read the details from the <code>ViewModel</code> and update the <code>TextView</code>, so that the text in the <code>TextView</code> is maintained when the device is rotated.</li>
    <li>Change the application so that the <code>ViewModel</code> holds a list of songs and <code>LiveData</code> of this list of songs, as in the "Using LiveData with ViewModel" example, above. Use an <code>Observer</code> in your <code>MainActivity</code> to observe changes in the <code>ViewModel</code>, updating the <code>TextView</code> when it updates so that it contains a list of songs so far.</li>
    </ul>
</li>
</ol>
</body>
</html>
