<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>
<title></title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" type="text/css" href="../css/android.css">
</head><body>

<div class="subtitle"><h1>Topic 1 - Introduction to Kotlin</h1></div><hr>
<h2>What is Kotlin?</h2>
<ul>
<li>A statically-typed,
object-oriented and functional programming language developed
by <a href="http://www.jetbrains.com/">JetBrains</a> - developers of the
IntelliJ IDE which Android Studio is based on</li>
<li>Compiles to Java bytecode, therefore compatible with the Java
Virtual Machine</li>
<li>Because of this,
Kotlin code can be mixed with Java code in one application</li>
<li>Main site: <a href="http://www.kotlinlang.org/">here</a></li>
<li><em>Recommended as the preferred language to develop Android apps</em>, so we will start the module with a look at the basics of Kotlin before beginning Android development</li>
</ul>
<hr><h2>Some Kotlin features</h2>
<ul>
<li><em>Null safety</em>: language features to helo guard against the
dreaded NullPointerException!</li>
<li><em>Type inference</em>: type of variables can be inferred by what they
are initialised to</li>
<li><em>Lambda functions</em>: anonymous functions which can be passed as
arguments to other functions (a la JavaScript)</li>
<li><em>Data classes</em>: concisely create classes which represent data and
do not need methods</li>
<li><em>Extension functions</em>: add a single function (method) to an
existing class without needing to subclass it</li>
<li><em>Coroutines</em>: a lightweight approach to multi-tasking.
producing code which is easier to follow compared to threads</li>
</ul>
<hr><h2>Hello World in Kotlin</h2>
<ul>
<li>Here is Hello World in Kotlin:
<pre>fun main (args: Array&lt;String&gt;) {
    println("Hello World!")
}
</pre>
</li>
<li>Note that in Kotlin, <strong>we do not need to create a class</strong>;
we can use just functions (similar to C++)</li>
<li>We have a main function, similar to the main method in Java</li>
<li><strong>fun</strong> is the keyword for a function, and <em>println()</em>
prints to the console, just like <em>System.out.println()</em> in Java</li>
<li>Note the different parameter syntax: main() has one parameter,
<em>args</em>, which is an <em>Array</em> of <em>String</em>s (representing
the command-line arguments, as in Java)</li>
<li>Note also that Kotlin does not use semicolons (you can use them, but
it is not recommended as it is unnecessary)</li>
</ul>
<hr><h2>Variables example</h2>
<ul>
<li>This example shows some aspects of how variables work in Kotlin:
<pre>fun main (args: Array&lt;String&gt;) {
    // Declare a as an Int. "val" means it is immutable (cannot be changed)
    val a: Int = 3

    // Type inference: "b" is an Int because it is initialised to an Int
    val b = 4
    
    // "c" is a "var", which means it can be changed
    var c = 5    

    // increase "c" by one
    c++

    // this would give a compiler error as "b" is immutable
    // b++

    // this would also give a compiler error as "c" is implicitly an Int
    //c = "A String"

    // Some other data types
    val d = 12345678L // Long
    val pi = 3.141592654 // Double
    val f = 1.23f // Float
    val str = "Hello" // String


    // Print them out. Note how we can embed variables in a string
    // by preceding them with '$'
    println("a is $a, b is $b, c is $c, d is $d, f is $f, pi is $pi, str is $str")
}
</pre>
</li>
<li>Note how we use <em>val</em> for immutable (unchanging) variables,
and <em>var</em> for mutable variables (those which can change)</li>
<li>Note how the type of a variable can be <em>inferred</em> by what value
we assign it to, in all variables above apart from "a", we do not declare
the type</li>
<li>Nonetheless the variables <em>are</em> typed, we cannot place a String
in "c", for example</li>
<li>See <a href="http://kotlinlang.org/docs/reference/basic-types.html">here</a> for details on Kotlin data types</li>
</ul>
<hr><h2>Loops in Kotlin</h2>
<ul>
<li>The program below shows some examples of basic loops:
<pre>fun main (args: Array&lt;String&gt;) {
    // Count from 1 to 10
    for (i in 1..10) {
        println(i)
    }

    // Count from 1 to 9 ("until" discounts 10 itself)
    for(j in 1 until 10) {
        println(j)
    }

    // count from 1 to 9 in steps of 2
    for(k in 1..9 step 2) {
        println(k)
    }
}
</pre>
</li>
<li>Note the syntax <em>1..10</em>. This is called a 
<em>range expression</em>. It returns a Range object representing the
range of numbers 1 to 10.</li>
<li>Note also the difference between the first two examples; 
<em>until</em> is a function which
returns a Range from the initial number up to, but
<em>not including</em>, the final number
    <ul>
    <li>So the second loop will only count from 1 to 9</li>
    </ul>
</li>
<li>We also have the standard, Java-style <em>while</em> loop too</li>
<li>See <a href="http://kotlinlang.org/docs/reference/control-flow.html">
here</a> for full documentation on loops</li>
</ul>
<hr><h2>Conditional statements in Kotlin</h2>
<ul>
<li>The program below shows some examples of conditional statements in
Kotlin:
<pre>fun main (args: Array&lt;String&gt;) {
    println("Enter your name:")
    val n = readLine()
    if (n == "Linus Torvalds") {
        println("You invented Linux")
    } else {
        println("You didn't invent Linux")
    }

    println("Enter your grade:")
    val grade = readLine()
    when(grade) {
        "A" -&gt; println("First")
        "B" -&gt; println("2.1")
        "C" -&gt; println("2.2")
        "D" -&gt; println("Third")
        "F" -&gt; { println("Fail")
                println("Please resit in the summer.") }
        else -&gt; println("Invalid grade $grade.")
    }
}
</pre>
</li>
<li>Note how if/else is similar to Java</li>
<li>The <em>when</em> statement is not in Java; it is similar to 
<em>switch</em> but has some interesting additional features, see next
slide</li>
<li>Note the use of <em>else</em> inside <em>when</em> to handle unmatched
conditions (e.g. here, if the grade is not A, B, C, D or F)</li>
</ul>
<hr><h2>Conditional expressions</h2>
<ul>
<li>An important difference in Kotlin compared to java is that conditionals
can be used as <em>expressions</em>, i.e. they can return a value
which can be assigned to a variable</li>
<li>eg. 
<pre>fun main (args: Array&lt;String&gt;) {
    println("Enter your name:")
    val n = readLine()

    // "msg" contains the result of the if statement
    val msg = if (n=="Linus Torvalds") "You invented Linux" else "You didn't invent Linux"
    println(msg)

    println("Enter your grade:")
    val grade = readLine()

    // "degree" contains the result of the when statement
    val degree = when(grade) {
        "A" -&gt; "First" // Return "First" when grade is "A"
        "B" -&gt; "2.1" // Return "2.1" when grade is "B"
        "C" -&gt; "2.2"
        "D" -&gt; "Third"
        "F" -&gt; "Fail"
        else -&gt; "Invalid grade $grade."
    }
    println("Degree awarded: $degree.")
}
</pre>
</li>
<li>Note in this example how we store the result of the <em>if</em>
statement in the variable <em>msg</em>
    <ul>
    <li>...so that <em>msg</em> wil contain either <em>You invented Linux</em>
    or <em>You didn't invent Linux</em>, depending on the name typed in</li>
    </ul>
</li>
<li>Also notice how the <em>when</em> statement similarly returns a value,
i.e. "First" when the grade is "A", "2.1" when the grade is "B", etc. </li>
</ul>
<hr><h2>Basic arrays, including for-in and if-in</h2>
<ul>
<li>Arrays are available in Kotlin, like most other languages</li>
<li>THe <em>in</em> keyword in Kotlin allows us to do foreach-style loops
with arrays and easily work out if a value is in an array</li>
<li>
<pre>fun main (args: Array&lt;String&gt;) {
    val langs = arrayOf("Python", "Java", "JavaScript", "PHP", "Kotlin")
    println("Languages you are learning at university:")
    for(curLang in langs) {
        println(curLang)
    }
    println("Please enter a programming language:")
    val lang = readLine()
    val msg = if(lang in langs) "learning" else "not learning"
    println("You are $msg $lang at university.")
}
</pre>
</li>
<li>Note the use of the if statement as an expression again
(<em>if(lang in langs)...</em>)</li>
<li>Next time we will cover some additional features of arrays, and
lists</li>
</ul>
<hr><h2>Nullability</h2>
<ul>
<li>One of the really useful features of Kotlin is <em>null safety</em></li>
<li>With Kotlin, you can declare a variable to either be nullable or
non-nullable</li>
<li>Non-nullable variables will produce a <strong>compiler error</strong>
if you attempt to store 'null' in them</li>
<li>Thus we can guard against the dreaded NullPointerException</li>
</ul>
<hr><h2>Non-nullable variables</h2>
<ul>
<li>By default, given data types (String, etc.)
are <em>non-nullable</em></li>`
<li>So this code will not compile, beacuse we declare <em>s</em> as a
non-nullable String and attempt to assign null to it
<pre>fun main (args: Array&lt;String&gt;) {
    var s: String = null
    println(s.length);
}
</pre>
</li>
<li>This is a better result than Java, in which the program would compile, but
crash with a NullPointerException when we try to access the length...</li>
</ul>
<hr><h2>Nullable variables</h2>
<ul>
<li>What about cases where we want the variable to be nullable?</li>
<li>For example, a collection of data which doesn't exist until we open 
a file and read it in from the file</li>
<li>In this case, we <em>explicitly declare the variable as nullable</em>
by adding a question-mark <em>?</em> to the data type</li>
<li>So, will this code successfully compile?
<pre>fun main (args: Array&lt;String&gt;) {
    var s: String? = null
    println(s.length);
}
</pre>
</li>
</ul>
<hr><h2>The safe-access operator</h2>
<ul>
<li>The answer is <em>no</em>, because even though we declared <em>s</em>
as a nullable string, we then try to access the length of a String object
which is null</li>
<li>In Java this type of operation would throw a NullPointerException</li>
<li>Kotlin's null-safety forces you to deal with this using the 
safe-access operator, <em>?.</em></li>
<li>Here is the previous example, rewritten to use the safe-access operator:
<pre>fun main (args: Array&lt;String&gt;) {
    var s: String? = null
    println(s?.length);
}
</pre>
</li>
<li>Here, due to the safe-access operator, we will only access the length
if "s" is not null</li>
</ul>
<hr><h2>A practical example, and introducing Elvis</h2>
<ul>
<li>The previous example was to illustrate the nullable concept only, and 
obviously does not do anything interesting</li>
<li>This example shows a more practical use of the safe-access operator;
note that <em>readLine()</em> returns a nullable String (<em>String?</em>):
<pre>fun main (args: Array&lt;String&gt;) {
    println("Please enter a number:")
    val str1 = readLine() // this might return null

    // Elvis: Set a EITHER to the return value of toInt(), or 0 if str1 is null
    val a = str1?.toInt() ?: 0

    println("Please enter another number:")
    val str2 = readLine() // this might return null

    // Elvis: Set b EITHER to the return value of toInt(), or 0 if str2 is null
    val b = str2?.toInt() ?: 0

    // Note how we can embed full expressions inside strings with $
    println("The sum of the two numbers is ${a+b}");
}
</pre>
</li>
<li>This example reads in two numbers as (nullable) strings, tries to
convert them to integers with the <em>toInt()</em> method, 
and prints the sum</li>
<li>Note how the safe-access operator is used to call <em>toInt()</em>
in case <em>str1</em> is null</li>
<li>What of the new operator, <em>?:</em> though?</li>
<li>This is known as the <em>Elvis operator</em> (why? apparently because it's 
the emoticon for Elvis Presley)</li>
<li>In cases where we're trying to
call a method (or access an attribute) of a nullable with the safe-access
operator, the Elvis operator allows us to set a value for a variable
normally obtained from the return value of the method 
in cases where the nullable is null</li> 
<li>So if either string (str1 or str2) is null, the corresponding Int
(a or b) will be assigned the value 0 rather than the return value of
<em>toInt()</em></li>
<li>More on nullability <a href="http://kotlinlang.org/docs/reference/null-safety.html">here</a>.</li>
</ul>
<hr><h2>Functions in Kotlin</h2>
<ul>
<li>The following example shows the use of functions in Kotlin, 
including parameters and return types:
<pre>
fun printString(s: String, nTimes: Int)
    for(i in 1..nTimes) {
        print(s)
    }
    print("\n")
}

fun cube(number: Double) : Double {
    return number * number * number
}

fun main (args: Array&lt;String&gt;) {
    printString("*", 3)    
    printString("#", 4)    
    printString("!", 5)    
    println("The cube of 3 is: ${cube(3.0)}")
}
</pre>
</li>
<li>Note the syntax for parameters 
    <ul><li><em>(s: String, nTimes: Int)</em></li></ul>
 and return types 
    <ul><li>fun cube(number: Double) : <em>Double</em>)</li></ul>
</li>
<li>Note also how we can put function calls in quotes using $, and {} to
contain the expression
    <ul><li> println("The cube of 3 is: <em>${cube(3.0)}</em>")</li></ul>
</li>
</ul>
<hr><h2>Classes and Objects in Kotlin</h2>
<ul>
<li>Like Java, you can do OO programming in Kotlin</li>
<li>Classes and objects work similarly to Java, but there are some differences
and enhancements</li>
<li>Here is a basic example (the famous Cat class...)
<pre>class Cat (n: String, a: Int, w: Int) {

    // Attributes
    val name: String
    var age: Int
    var weight: Int
    
    // Init block, for performing tasks on creation of the object
    init {
        name = n
        age = a
        weight = w
    }

    fun walk() {
        this.weight--
    }

    fun display() {
        println("Name: $name Age: $age Weight: $weight")
    }
}

fun main (args: Array&lt;String&gt;) {
    val felix = Cat("Felix", 10, 10)
    val tom = Cat("Tom", 5, 5)
    felix.walk()
    tom.walk()
    felix.display()
    tom.display()
}
</pre>
</li>
<li>Note how we <strong>place the constructor parameters (name, age and
weight) immediately after the class name</strong> - this is different to
Java in which we create a constructor function inside the class body</li>
<li>Note also the <strong>init block</strong>. This contains code we want
to run when the object is first created. Here, we simply set the 
attributes equal to the constructor parameters</li>
<li>The methods walk() and display() are similar to Java.</li>
</ul>
<hr><h2>Making our class more concise - automatically setting 
constructor parameters equal to class attributes</h2>
<ul>
<li>This version of the previous example is more concise:
<pre>class Cat (val name: String, var age: Int, var weight: Int) {

    fun walk() {
        this.weight--
    }

    fun display() {
        println("Name: $name Age: $age Weight: $weight")
    }
}


fun main (args: Array&lt;String&gt;) {
    val felix = Cat("Felix", 10, 10)
    val tom = Cat("Tom", 5, 5)
    felix.walk()
    tom.walk()
    felix.display()
    tom.display()
}
</pre>
</li>
<li>Note how we <em>specify either val or var before each 
constructor parameter</em></li>
<li>
This <strong>automatically makes each parameter an attribute of the class
</strong></li>
<li><em>val</em>s will be immutable, <em>var</em>s will be mutable</li>
<li>Thus, unlike the previous version, we do not have to declare the
attributes inside the class, or use an init block</li>
</ul>
<hr><h2>Data classes - concisely representing complex data structures
</h2>
<ul>
<li>In many cases, we need to create classes which represent a complex data
structure, but do not need methods</li>
<li>A good example would be a <em>Point</em> class, to represent a 
2D point (with x and y coordinates)</li>
<li>In Java, you could do this (note how x and y are public, to avoid
the need for getters and setters; an implementation which wanted to
make x and y immutable would need to make them private and add getter methods):
<pre>public class Point {
    public int x, y;

    public Point (int x, int y) {
         this.x = x;
         this.y = y;
    }
}
</pre>
</li>
<li>However, having to create a constructor to initialise the attributes
to the constructor parameters is a pain</li>
<li>In Kotlin, in an extension of the previous example,
you can create a Point class with just
<strong>one line of code</strong>:
<pre>data class Point(val x:Int, val y: Int)</pre>
</li>
<li>That is it! This will create a Point class, with a two argument
constructor (x and y), and two immutable (because of <em>val</em>) 
attributes, also x and y</li>
<li>This could be used in a main() function as follows:
<pre>data class Point(val x:Int, val y: Int)

fun main (args: Array&lt;String&gt;) {
    val p = Point(0, 5)
    val p2 = Point(5, 2)
    println("${p.x} ${p.y}")
    println("${p2.x} ${p2.y}")
}
</pre>
</li>
<li>Much more concise code!</li>
</ul>
<hr><h2>More on Functions in Kotlin</h2>
<ul>
<li>In Kotlin, functions can be <em>stored in variables</em> and
<em>passed as arguments to other functions</em>
    <ul>
    <li>In this respect, Kotlin is similar to JavaScript</li>
    </ul>
</li>
<li>This property of functions makes them <em>first class</em>
(see <a href="https://kotlinlang.org/docs/reference/lambdas.html">the Kotlin documentation</a>)</li>
<li>This can allow for some powerful programming techniques,
e.g. operating on all members of an array or list using a function,
allowing us to adopt a functional programming style</li>
<li>..or, allowing us to pass a function as a <em>callback</em> to another function, helping
this function become more loosely-coupled</li>
</ul>
<hr><h2>First.. introducing some more Kotlin collections</h2>
<ul>
<li>Last time we looked at how to create simple <em>arrays</em></li>
<li>However, we can also use Java-style <em>collections</em> in Kotlin, e.g. List, HashMap</li>
<li>The syntax and initialisation methods are, however, a little different</li>
<li>In Kotlin, collections divide into <em>mutable</em> collections (those that can be altered) and
<em>immutable</em> collections (those which cannot, which are more efficient in cases where the data in
the collection never changes)</li>
</ul>
<hr><h2>The List</h2>
<ul>
<li>This example shows basic use of a List:
<pre>fun main(args: Array&lt;String&gt;) {
    val peopleList = listOf("Mark Cranshaw", "Rob Cooper", "Al Monger", "Mark Udall", "Margaret Jones")
    for(p in peopleList) {
        println("$p was formerly a lecturer at Solent University.")
    }
}
</pre>
We create a list of former lecturers at the university and use a <em>for/in</em> loop
to iterate through each</li>
<li>Note that <em>listOf()</em> returns an <em>immutable</em> list (a list of type List);
this cannot be altered (e.g. it does not have an <em>add()</em> method)</li>
</ul>
<hr><h2>Creating a Mutable List</h2>
<ul>
<li>This example shows basic use of a mutable List:
<pre>fun main(args: Array&lt;String&gt;) {
    val peopleList = <em>mutableListOf</em>("Mark Cranshaw", "Rob Cooper", "Al Monger", "Mark Udall", "Margaret Jones")
    <em>peopleList.add("Roger Forster")</em>
    for(p in peopleList) {
        println("$p was formerly a lecturer at Solent University.")
    }
}
</pre>
Note how we use <em>mutableListOf</em></li>
<li>This returns an object of type <em>MutableList</em>, which has an <em>add()</em> method</li>
<li>Also note that <em>peopleList</em> is <em>val</em>, not <em>var</em>, even though it's a MutableList
    <ul>
    <li>Even though we add new data to the list, the actual object reference <em>peopleList</em>
    (which represents the memory address of the list) does <em>not</em> change</li>
    <li>Hence we can use a <em>val</em>ue for this example</li>
    </ul>
</li>
<li>We can create an empty list by omitting the arguments, e.g:
<pre>val peopleList = mutableListOf<em>&lt;String&gt;</em>()</pre>
</li>
</ul>
<hr><h2>Anonymous Functions</h2>
<ul>
<li>An <em>anonymous function</em> is a function with no declared name after the <em>fun</em> keyword</li>
<li>Anonymous functions can be passed in as 
arguments to another function, or referred to via variables</li>
<li>Here is a basic example of an anonymous function, referred to by the variable <em>funcReference</em> here:
<pre>fun main(args: Array&lt;String&gt;) {
    val funcReference = fun(i: Int): Int { return i*i*i }
    println(funcReference(3))
    val secondRef = funcReference
    println(secondRef(4))
}
</pre>
</li>
<li>Note how we set <em>funcReference</em> equal to a function which has one Int parameter, returns Int and
calculates and returns the cube of the number</li>
<li><em>funcReference</em> is a reference to this anonymous function</li>
<li>We can use this reference to call the function</li>
<li>Notice how we can also set up a <em>second</em> reference (<em>secondRef</em> here)
to the function, and use that to call it</li>
</ul>
<hr><h2>Passing functions as arguments to other functions</h2>
<ul>
<li>In Kotlin, we can <em>pass functions as arguments to other functions</em></li>
<li>The parameter type for a function passed into another is:
<pre>(ParamType1, ParamType2, ParamType3...) -&gt; returnType</pre>
where <em>ParamType1, ParamType2, ParamType3</em> etc. are the parameter types for the 
function being passed in, and <em>returnType</em> is the return type of that function</li>
<li>This is probably better explained via example, so here is one:
<pre>fun main(args: Array&lt;String&gt;) {
    val cubeFunction = fun(i: Int): Int { return i*i*i }
    execFunction(cubeFunction)
}

fun execFunction ( f: (Int) -&gt; Int) {
    println(f(3)) // call the function passed in with an argument of 3, i.e. the cube of 3 will be calculated
}
</pre>
Note that we pass <em>cubeFunction</em> in as an argument to <em>execFunction</em></li>
<li>The corresponding data type of the parameter, <em>f</em>, is <em>(Int) -&gt; Int</em>,
to indicate that the function being passed in takes one Int and returns an Int</li>
<li>If the function being passed in returns nothing, we specify <em>Unit</em> as the return type, e.g:
<pre>fun main(args: Array&lt;String&gt;) {
    val printStars = fun(i: Int){ 
        for(count in 1..i) {
            print("*")
        }
        print("\n")
    }
    execFunction(printStars)
}

fun execFunction ( f: (Int) -&gt; <em>Unit</em>) {
    f(3)// call the function passed in with an argument of 3, i.e. three stars will be printed
}
</pre>
This time we pass in a function which prints a given number of stars, but does not return
anything, hence specifying <em>Unit</em> as the return type of the function passed into <em>execFunction</em>
</li>
</ul>
<hr><h2>Lambda functions</h2>
<ul>
<li><em>Lambda</em> functions are similar to ordinary anonymous functions but use a special, concise syntax</li>
<li>Here is the first example rewritten to use a lambda function:
<pre>fun main(args: Array&lt;String&gt;) {
    val cubeLambda: (Int) -&gt; Int =  { i -&gt; return i*i*i }
    println(cubeLambda(3))
}
</pre>
</li>
<li>Note how we write a lambda: we enclose the whole function (the parameters as well as the function body)
in braces { }, and separate the parameters and the function body with the <em>-&gt;</em> token</li>
<li>Note how we have to specify the <em>type</em> of the lambda:
<pre>val cubeLambda: (Int) -&gt; Int</pre>
This is because we do not specify the parameter types in the lambda, therefore we have to specify the type of
the variable holding it</li>
<li>Note how in our case, the lambda only has one statement (<em>return i*i*i</em>), but they can
actually have multiple statements, one statement per line; e.g.
<pre>val someLambda: (Int) -&gt; Int = { parameter-&gt;
    statement1
    statement2
    return someValue
}
</pre>
</li>
<li>See <a href="https://kotlinlang.org/docs/reference/lambdas.html">the Kotlin documentation</a> for more details</li>
</ul>
<hr><h2>Making the lambda more concise - I</h2>
<ul>
<li>We can make the previous version more concise</li>
<li>With lambdas, <em>the value declared in the last line is always automatically returned</em></li>
<li>So the code below will also have the same effect as the previous example:
<pre>fun main(args: Array&lt;String&gt;) {
    val conciseCubeLambda: (Int) -&gt; Int =  { i -&gt; i*i*i }
    println(conciseCubeLambda(3))
}
</pre>
Because the last statement of the lambda is always returned, and that last statement here is <em>i*i*i</em>,
it follows that <em>i*i*i</em> will be returned from the lambda in this example, and the desired effect of
returning the cube will be achieved</li>
</ul>
<hr><h2>Making the lambda more concise - II - the implicit "it"</h2>
<ul>
<li>It doesn't stop there!</li>
<li>In cases in which a lambda has just <em>one</em> parameter - a common situation - we can refer to
that one parameter implicitly using the keyword <em>it</em></li>
<li>Thus, we can rewrite the cube example as follows:
<pre>fun main(args: Array&lt;String&gt;) {
    val cubeLambdaWithIt: (Int) -&gt; Int =  { it*it*it }
    println(cubeLambdaWithIt(3))
}
</pre>
Because the <em>it</em> parameter always corresponds to a single argument passed in (3 in this example),
and because the value of last statement of a lambda is always returned, it follows that this example
will also calculate the cube of the argument passed into the lambda</li>
</ul>
<hr><h2>Real-world use of lambdas</h2>
<ul>
<li>A very common real-world use of lambdas is to write code in a <em>functional</em> style</li>
<li>A typical pattern in functional code is to <em>apply a given function to all members of an array,
list or map</em></li>
<li>This leads to more readable, intuitive code with the details of looping through the collection
hidden away</li>
<li>Collections (lists, maps) have a range of functions (methods) which apply a lamda to some or all members of
the collection</li>
<li>The simplest is <em>forEach()</em>, which applies a lambda to all members of a collection:
<pre>fun main(args: Array&lt;String&gt;) {
    val peopleList = listOf("Mark Cranshaw", "Rob Cooper", "Al Monger", "Mark Udall", "Margaret Jones")
    peopleList.forEach { person -&gt; println(person) }
}
</pre>
</li>
<li>Note how the <em>forEach()</em> method of the list takes a lambda as an argument</li>
<li>The lambda will be applied to all members of <em>peopleList</em>, with each person in turn being passed into
the lambda as the <em>person</em> parameter</li>
<li>The result, therefore, will be that each person will be printed</li>
<li>Note also how we can omit the parentheses () when passing in a lambda as the first argument to a function</li>
</ul>
<hr><h2>Question</h2>
<ul>
<li>How can we make
<pre>peopleList.forEach { person -&gt; println(person) }</pre>
more concise?</li>
<li>Answer will be given out in class!</li>
</ul>
<hr /><h2>Mappings: performing the same operation on all members of a list</h2>
<p>Another common use of lambdas is to perform a <em>mapping</em>. A mapping transforms each member of an input list by a specified function, and returns a new list containing the transformed data. This example will convert each string in the input list to lower case:
<pre>fun main(args: Array&lt;String&gt;) {
    val peopleList = listOf("Mark Cranshaw", "Rob Cooper", "Al Monger", "Mark Udall", "Margaret Jones")
    val lowerCaseList = peopleList.map { person -&gt; person.lowercase() }
    println(lowerCaseList)    
}</pre>
Note how we use the <code>map()</code> function to transform each member of <code>peopleList</code> by a specified lambda. The lambda here will take each member of the input list in turn (<code>person</code>) and return that member converted to lower case (i.e. <code>person.lowercase()</code>). The resulting lower case string will be placed at the corresponding position in a new list, returned by the <code>map()</code> function. So, in this example, <code>lowerCaseList</code> will be a list of all the lower-case names.</p>
<h2>Further reading</h2>
<p>I have prepared some notes on additional basic Kotlin topics, including inheritance and map data structures. There is unfortunately no time in the lecture to cover these, but <a href='topic1a.html'>please read the notes here</a>.</p>
</body></html>
