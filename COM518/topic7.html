<!DOCTYPE html>
<html>
<head>
<title>Topic 7.h: Further Node and Express: Modules, Routers and Middleware</title>
<meta http-equiv='Content-Type' content='text/html;charset=ISO-8859-1' />
<link rel='stylesheet' type='text/css' href='../css/dfti0910.css' />
</head><body>
<div class='titlebox'>
<h1>Topic 7: Further Node and Express: Modules, Routers and Middleware</h1>
</div>
This week we will look at
<ul>
<li>Using Node <em>modules</em> from an Express application;</li>
<li>Using the Express <em>router</em> to organise and group routes;</li>
<li>Using <em>middleware</em> to intercept requests before they are processed by routes, and therefore perform <em>pre-processing tasks</em>.</li>
</ul>

<h2>Modules</h2>
<p>So far, we have written our Express server in one file. That is fine when the application is small, but if you need to develop a larger, more complex application, the file will quickly become hard to follow, and thus hard to maintain. We can make our code more maintainable by <em>splitting our routes into groups</em>, all dealing with the same type of entity (for example, songs or users). You can achieve this by creating a separate <em>router</em> for each related group of routes, in a separate file called a <em>module</em>, which can be <em>imported</em> from your main server file.</p>
<p>There are two approaches for implementing modules, <em>CommonJS modules</em> and <em>ECMAScript 6 modules</em>. ECMAScript 6 modules are a web standard, and are increasingly well supported, so we will use ECMAScript 6 modules.</p> 

<h3 id="anexampleecmascript6module">An example ECMAScript 6 module</h3>
<p>The whole idea of modules is to write <em>reusable code</em> that can be <em>imported into any project</em>. Here is an example of a simple module. You'll notice that most of it is simple JavaScript. Only the <code>export</code> statement at the end makes it a module. <strong>Modules can be used in both Node.js and client-side, in-browser, JavaScript.</strong>
</p>
<p>Note that the standard for ECMAScript 6 modules is to use the <code>.mjs</code> extension (JavaScript module) rather than <code>.js</code>. You must use this convention from Node.js, and it is optional in browsers.</p>
<pre><code class="javascript language-javascript">
// Module mymaths.mjs

function square(n) {
    return n * n;
}

function cube(n) {
    return n * n * n;
}

export { square, cube };
</code></pre>
<p>Note how this module contains two functions, <code>square()</code> and <code>cube()</code>, which calculate the square and the cube of of a number, respectively. However the interesting thing is the statement at the end:</p>
<pre><code class="javascript language-javascript">export { square, cube };
</code></pre>
<p>This statement <em>exports the two functions, so that they can be used from the outside world</em>. This file would be saved as a simple JavaScript file, e.g. <code>mymaths.mjs</code>.</p>
<h3 id="usingthemodulefromanotherfile">Using the module from another file</h3>
<p>We've created a simple module, but how might we use it from another file?
We need to <code>import</code> the functions that have been exported. This could be done from your main server in a Node/Express example, or from browser-based JavaScript. Here's an example of using the module from the main file of a client-side JavaScript application. This is often named <code>index.mjs</code> by convention.</p>
<pre><code class="javascript language-javascript">// index.mjs - 'main' JavaScript file

// Import the two functions from the module. 
// Note the './' before 'mymaths.mjs'. This means 'the current folder'
import { square, cube } from './mymaths.mjs';

const a = square(3);
console.log(`The square of 3 is : ${a}`);

const b = cube(2);
console.log(`The cube of 2 is : ${b}`);
</code></pre>
<p>Note how we have to <em>import</em> the functions from the module before we can use
them. This makes for easier-to-read code as we can tell exactly where the
two functions <code>cube()</code> and <code>square()</code> have come from.</p>
<h3 id="includingmodulesintoawebpage">Including modules into a web page</h3>
<p>To actually make this code run in a browser, we need to link it to an HTML web page which can be executed from the browser.</p> 
<p>In a browser, we link a module in the same way as a regular JavaScript file, except we use <code>&lt;script type='module'&gt;</code>. Note that the main JavaScript file, <code>index.mjs</code>, is itself a module. It's the 'main module' of the application and it's using another module, <code>mymaths.mjs</code>. We have actually seen this already, in week 3. For example:</p>
<pre><code class="html language-html">&lt;html&gt;
&lt;head&gt;
&lt;script type='module' src='index.mjs'&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
...
</code></pre>
<p>A critical point is that <strong>you have to access your site via a web server</strong> to use modules. You can use your own Express server, or if you want to test quickly, you can easily set up a web server in the current folder with:
<pre>npx http-server</pre>
and then access pages on port 8080, e.g:
<pre>http://localhost:8080/index.html</pre>
</p>
<h3 id="example2onlyimportingsomefunctions">Example 2: Only importing some functions</h3>
<p>It's possible to only import <em>some</em> functions from a module. For instance this version of our <code>index.mjs</code> code:</p>
<pre><code class="javascript language-javascript">// index.mjs - 'main' JavaScript file

// Import cube() (only) from the module. 
import { cube } from './mymaths.mjs';

// Call the cube() function from the module
const a = cube(3);
console.log(`The cube of 3 is : ${a}`);

// This will not work now, as square() was not imported from the module
const b = square(4);
console.log(`The square of 4 is : ${b}`);
</code></pre>
<h3 id="example3groupingallmembersofanexportedmoduleintoamoduleobject">Example 3: Grouping all members of an exported module into a module object</h3>
<p>It can be a little messy to import each function
separately. It would be nicer if we could <em>collect together all module
exports as a single object</em> when we import them. This approach is frequently used with libraries, such as three.js. This version of <code>index.mjs</code> shows this:</p>
<pre><code class="javascript language-javascript">// index.mjs - 'main' JavaScript file

// Import the two functions from the module into a module object 'MyModule'
import * as MyModule from './mymaths.mjs';

// Call the functions from the module

const a = MyModule.square(3);
console.log(`The square of 3 is : ${a}`);
const b = MyModule.cube(4);
console.log(`The cube of 4 is : ${b}`);
</code></pre>
<p>Note how this differs from the first two examples. First, consider the
<code>import</code> statement:</p>
<pre><code class="javascript language-javascript">import * as MyModule from './mymaths.mjs';
</code></pre>
<p>Rather than importing each function separately, they are all being imported
as a single <em>module object</em>, MyModule. You can reference each exported 
function by referencing the module object name, then a dot, then the function
name, for example <code>MyModule.cube(...)</code>. </p>
<p>(To relate this to object-oriented programming, which we did in your web module last year and you may have done COM528, <code>MyModule</code> is an <em>object</em> and <code>cube()</code> is a <em>method</em> of that object).</p>
<h3 id="example4defaultexport">Example 4: Default export</h3>
<p>If your module only needs to export one function or object, you can declare
this as the <em>default export</em>. This is another way of achieving the effect of the previous example, with all exports from a module packaged into a single
object. However, with a default export, we group everything together as an object when <em>exporting</em>, rather than when importing. So here is an example of the module using a default export:</p>
<pre><code class="javascript language-javascript">function _cube(name) {
    return n*n*n; 
}

function _square(n) {
    return n*n;
}

const exportedObject = {
    cube: _cube,
    square1: _square,
    PI: 3.141592654
};

export default exportedObject;
</code></pre>
<p>This exports a default object with two fields: The <em>cube</em> field is set
equal to the function <code>_cube()</code> (note that an underscore is a convention in JavaScript for a 'private' or 'internal function), and the <em>square</em> field is set equal to the function <code>_square()</code>.</p>
<p>We can then use the default export in our main module using:</p>
<pre><code class="javascript language-javascript">import MyDefaultObject from './mymaths.mjs';
</code></pre>
<p>This will import the <em>default</em> export from the module as <code>MyDefaultObject</code>, so we can then call the methods with:</p>
<pre><code class="javascript language-javascript">const a = MyDefaultObject.cube(4);
const b = MyDefaultObject.square(9);
</code></pre>
and we can also use the constant <code>PI</code>, as that is included in the exported object:
<pre>console.log(MyDefaultObject.PI);</pre>
</p>
<h2>Express Routers</h2>
<p>Having looked at modules, we will now look at how to implement an Express <em>router</em> as a module.</p>
<h3>Implementing an Express Router as a Module</h3>
<p>In a larger application, you will quickly find that your main Express file (often <code>app.mjs</code>) will become very large, handling a large number of routes. What you can do instead is to define a <em>Router</em>. A router allows you to set up a group of routes which match a particular path. For example we might create a router matching the path <em>/products</em> which will handle any routes beginning with <em>/products</em>, e.g: <em>/products/all</em>, <em>/products/id/:id</em> and so on. To do this we create a <em>routes</em> folder within the folder containing our main Express server, and place a route handler in there, which would be saved as a Node module.  Here is an example router module (<em>product.mjs</em>) which we would save in our <em>routes</em> folder:
<pre>
// routes/product.mjs 

import express from 'express';
const productRouter = express.Router();

productRouter.get('/all', (req,res)=&gt; {
    // code to return all products
});

productRouter.get('/id/:id', (req,res)=&gt; {
    // code to find the product with the given ID
});

export default productRouter; // export the module for external use
</pre>
Note how we are making <code>productRouter</code> the default export from this module, which means we'll be able to import it as follows:
<pre>import productRouter from './routes/product.mjs';</pre>
This is shown in the full Express application, below:
<pre>
import express from 'express';
const app = express();

// Import our product router module which we created above
import productRouter from './routes/product';

// Tell the app to use productRouter for all routes beginning with /products
// As we are using "use()", the router is acting as a middleware - see below
app.use('/products', productRouter);
app.listen(3000);
</pre>
So the song router is imported from the <em>routes/product</em> module
(corresponding to routes/product.mjs) and then we call <em>use()</em> 
with two arguments:
    <ul>
    <li><em>/products</em>, indicating that this router will <strong>handle all URLs beginning with <code>/products</code></strong>;</li>
    <li>The router object itself.</li>
    </ul>
So, the route <code>/products/all</code> will be handled via the product 
router (as the route begins with <code>/products</code>) and then via the <code>/all</code> route within the <code>products</code> router.</p>

<h2>Middleware</h2>

<p>Express uses the concept of <em>middleware</em>. Middleware in 
the context of web APIs consists of code which runs before a request is handled,
which can modify the <em>req</em> and <em>res</em> objects. It is typically
used to prepare the request before it's handled, or intercept requests to perform operations such as logging. <code>express.json()</code>, which you have already seen, is actually middleware. It parses JSON from the body of the incoming HTTP request and adds a <em>body</em> property to the <em>req</em> object allowing you to easily access POST data. Without the middleware, the <em>body</em> property of <em>req</em> would not exist.</p>
<p>Middleware is included with the <code>use()</code> method of your <code>app
</code> object, or with <code>get()</code> and <code>post()</code> if you only want a certain piece of middleware to run with GET and POST requests, respectively. Revisiting the use of <code>express.json()</code>, note how it is included with <code>use()</code>:
<pre>app.use(express.json());</pre>
<code>express.json()</code> is a function that returns middleware to parse JSON in the request body.
</p>
<h3>Writing our own middleware</h3>
<p>You will frequently want to write <em>your own middleware</em>. A piece of middleware is simply a function which takes three parameters - described below - and can examine the request or modify the request and/or the response. The three parameters taken by a middleware function are:
    <ul>
    <li>the request object (typically called <code>req</code>);</li>
    <li>the response object (typically called <code>res</code>);</li>
    <li>the next function in the middleware chain (see below; typically called <code>next</code>).</li>
    </ul>
We write our middleware function and then <code>use()</code> it from our Express application object.</p>
<p>Here is a simple example of a middleware that will run on any request. This will simply log the time of any request.
<pre>
import express from 'express';
const app = express();

app.use( (req,res,next) =&gt; {
    console.log(`Received a request at ${Date.now()} milliseconds.`);
    next();
});

app.get('/', (req,res) =&gt; {
    res.send(`Hello world!`);
});

app.listen(3000);
</pre>
Note how <em>use()</em> expects a function which takes request and response
as parameters, the same as the route handlers, as well as <code>next</code>. This example writes a message to the console informing the user of the time of the request.</p>
<p>Notice the call to the <em>next();</em> function (also passed as a
parameter to use()). This calls the next function in the middleware chain.
What do we mean by this? It is important to note that we can <em>specify multiple items of middleware via multiple <code>use()</code> calls</em>. Each item of middleware is called in the order it is specified, as long as <code>next()</code> is called from the previous item. So, if another middleware function is specified after this one, it will be called with <code>next()</code>. If there is no middleware after this one, the route handler itself will be called with <code>next()</code>.</p>
<p>The diagram below shows how the request can pass through multiple items of
middleware before reaching the route handler:
<br />
<img src="../images/middleware.png" alt="Multiple items of middleware" />
</p>
<h3>Another example - CORS</h3>
<p>Here is a second example (snippet only, not the whole server) which adds a <a href='topic3.html#cors'>CORS</a> header to all responses to allow clients from any domain to connect. In this example, the middleware will be added as a custom function which will allow any client to connect to this server.
<pre>
app.use((req, res, next) =&gt; {
    res.set('Access-Control-Allow-Origin', '*');
    next();
});
</pre> 
Note how we specify a custom arrow function as the argument to <code>use()</code>. This is our middleware, and you can see that it takes <code>req</code>, <code>res</code> and <code>next</code> parameters as described above. Note how our midleware <strong>adds the CORS <code>Access-Control-Allow-Origin</code> header to the response object</strong> to allow any domain to connect, and then calls the next function in the middleware chain with <code>next()</code>.</p>
<h3>Writing middleware as a separate function in a module</h3>
<p>Furthermore, we can write the middleware as a separate function, rather than an arrow function, as long as it has the required <code>req</code>, <code>res</code> and <code>next</code> parameters. The advantage of this method is that your function can be placed inside a module and imported into other projects. Here is an example of writing our CORS middleware as a separate function in a module:
<pre>
// corsMiddleware.mjs
function corsMiddleware(req, res, next) {
    res.set('Access-Control-Allow-Origin', '*');
    next();
}

export default corsMiddleware;
</pre>
We could then <code>import</code> this from our main server, and <code>use()</code> it, as follows:
<pre>import express from 'express';
const app = express();

// Require the middleware module
import corsMiddleware from './corsMiddleware';

// use() it
app.use(corsMiddleware);

// Routes
app.get('/', ...);

// etc

app.listen(3000);</pre>
</p>


<h3>Middleware with specific routes</h3>
<p>We can use routes to specify that a given middleware will only
run before handling <em>a particular route</em>. This can be useful as,
we might want certain middleware to only run in response to certain
requests.  We do this by supplying an optional first argument to <em>use()</em> to specify which routes will run this middleware. For example,
the middleware below (showing the time of the request once again)
will only run with a route of <em>search</em> followed by a search term:
<pre>
import express from 'express';
const app = express();

// Note that middleware only runs with /search/:query route
app.use( '/search/:query', (req,res,next) =&gt; {
    console.log(`Received a request for /search at ${Date.now()} milliseconds.`);
    next();
});

// Middleware not called
app.get('/', (req,res) =&gt; {
    res.send(`Hello world!`);
});

// Middleware called
app.get('/search/:query', (req,res) =&gt; {
    res.send(`Searching for ${req.params.query}...`);
});

app.listen(3000);
</pre>
</p>
<h3>Middleware with specific HTTP methods</h3>
<p>Furthermore, we can specify that middleware will only run for specific HTTP methods (GET, POST, DELETE, etc). We do this by replacing <code>use()</code> with a function representing the HTTP method (<code>get()</code>, <code>post()</code> etc). A good real-world use of this would be to prevent access to routes which modify data (POST, DELETE, PUT) unless you're logged in. For example:
<pre>
import express from 'express';
const app = express();

// This middleware will only run with POST requests, due to the use of
// app.post() rather than app.use()
// * means 'match all', so this middleware will run with all POST requests
app.post( '*', (req,res,next) =&gt; {
    console.log(`Received a POST request at ${Date.now()} milliseconds.`);
    next();
});

// Middleware not called
app.get('/', (req,res) =&gt; {
    res.send(`Hello world!`);
});

// Middleware called, because it uses post()
app.post('/product/new', (req,res) =&gt; {
    // Code to add a product to the database
});

app.listen(3000);
</pre>
</p>
<h3>Using multiple middleware with one statement</h3>
<p>You can use multiple items of middleware in <em>one</em> <code>use()</code>, <code>get()</code> or <code>post()</code> call. You specify each middleware function as a successive parameter, so that the syntax is:
<pre>
app.use('/route', middleware1, middleware2, middleware3...);
</pre>
So, for example:
<pre>
app.use( '/testroute', (req, res, next) =&gt; {
            console.log('Running middleware 1')
            next();
        },
         (req, res, next) =&gt; {
            console.log('Running middleware 2')
            next();
        } 
);
</pre>
In this example, all requests to <code>/testroute</code> will be intercepted by <em>both</em> specified middleware functions, and both messages will be displayed on the console, in order (the first specified function will run first).</p>
<h3>Using middleware to prevent access to a route under certain conditions</h3>
<p>As implied in the previous section, you can use middleware to <em>prevent the route ever being called under certain conditions</em>. A good example would be to implement a check that the user is logged in before they can access certain sensitive routes. You can prevent access to given routes by only calling <code>next()</code> if a certain condition is met, otherwise you send back a response (from the middleware) indicating that the main route cannot be processed. In the example below, the middleware handling the <code>/christmasSurprise</code> route tests whether it's December. If it is, then the <code>/christmasSurprise</code> route is called with <code>next()</code>. if not, the user is told to come back when it's Christmas!
<pre>
import express from 'express';
const app = express();

// Christmas checker middleware: is it December?
app.use('/christmasSurprise', (req, res, next) =&gt; {
    // Create an object representing today's date
    const d = new Date();

    // Get the current month, note that d.getMonth() gives a month in the range
    // 0-11 so we have to add one to get the normal numbering (1-12)
    const month = d.getMonth() + 1;

    // If it's December, let the client access the route
    if (month == 12) {
        next();
    // If not, tell them to come back later!
    } else {
        res.send(`It's not Christmas yet, come back in ${12 - month} months!`); 
    }
});

// Christmas surprise route, "guarded" by the middleware above
app.get('/christmasSurprise', (req, res) =&gt; {
    const html = "&lt;h1&gt;HERE IS YOUR CHRISTMAS SURPRISE!&lt;/h1&gt; ... etc ...";
    res.send(html);
});

app.listen(3000);
</pre>
</p>
<h2>dotenv - Environment variables</h2>
<p>Finally this week we will cover a useful Node module, <code>dotenv</code>. The <code>dotenv</code> module allows developers to specify <em>environment variables</em> - variables which can be set by the user as input to the application and may change - within a file, <code>.env</code>. Examples of such variables might include database name, username and password. This also has a security advantage: by adding private data to your <code>.env</code> it means that you can keep information such as passwords outside your source code, and publish your code to GitHub or another repository without giving away such information.</p>
<p><code>dotenv</code> is quite easy to use. Firsst of all, as it's a third-party module, you have to install it:
<pre>npm install dotenv</pre>
You then <code>import</code> it, for example below we import <code>dotenv</code> after we have initialised our Express app object.
<pre>
import express from 'express';
const app = express();
<em>import 'dotenv/config';</em>
</pre>
Environment variables are placed within the <code>.env</code> file as a series of key/value pairs. For example, here is a <code>.env</code> file containing database settings:
<pre>
DB_HOST=localhost
DB_USER=root
DB_DBASE=mysql
</pre>
We could then use these in our server via the <code>process.env</code> object. So we could use <code>process.env.DB_USER</code> to access the database user, <code>process.env.DB_HOST</code> to access the machine running the database, and <code>process.env.DB_DBASE</code> to access the database name. For example, if we were using MySQL, which requires a host, username and password, we could do:
<pre>
const con = mysql.createConnection({
    host: process.env.DB_HOST,
    user: process.env.DB_USER,
    database: process.env.DB_DBASE
});
</pre>
It's important to understand that <em>you can only use <code>process.env</code> after you have imported <code>dotenv</code></em>, as shown above.</p>
<hr />
<h2>Exercise</h2>
<p>The exercise will allow you to practise with routers, middleware and <code>dotenv</code>.</p>
<p><strong>IMPORTANT:</strong> This is a slightly more advanced topic, so you need to ensure you fully understand the material from Weeks 1-4 and 6 before attempting it. Please ensure that you have completed last week (Week 6) first, and also the standard exercises for Weeks 1-4.</p>
<ol>
<li>Make a <em>copy</em> of your Express server, so you still have the original version for reference.</li>
<li>Available <a href='wadsongs.db'>here</a> is an updated wadsongs.db to use, including an <code>ht_users</code> table for users. Note the <code>ht_users</code> table has these columns: username, password, name, dayofbirth, monthofbirth, yearofbirth, balance, isadmin, id. Download this, so it replaces your existing wadsongs.db.</li> 
<li>Create a separate <em>router</em> file, containing routes for users. This should be named <code>users.mjs</code>, should create an <code>express.Router()</code> as shown in the second example, and should contain two routes relating to users. These should be:
    <ul>
    <li>An <code>/allUsers</code> route which returns details of all users as JSON; </li>
    <li>a <code>/user/:username</code> route which returns details of a specific user, identified by username.</li>
    </ul>
</li>
<li>Include the router you have just created in your main Express app under the top-level route <code>/users</code>, as shown in the example.</li>
<li>Test it out by trying out the following in your browser (type in the URL directly, do not access from AJAX):
    <ul>
    <li>List all users;</li>
    <li>Look up a user by username.</li>
    </ul>
</li>
<li>Now, similarly, move all your routes to handle songs (i.e. everything you did in week 2) to a separate router inside the file <code>songs.mjs</code>. In the same way that you did for your <code>users</code> router, include this router under the top-level route <code>/songs</code>, and test it by searching for all songs by a particular artist by requesting the correct URL in your browser.</li> 
<li>Install <code>dotenv</code> and <code>import</code> it in your main server application. Add <em>middleware</em> to your server so that any <code>POST</code> request can only be accessed if the environment variable <code>process.env.APP_USER</code> exists. (This is a way of simulating a user being logged in without writing a full login system, which we have not done yet). To test whether <code>process.env.username</code> exists we can test whether it's <code>undefined</code>: 
<pre>
if(process.env.APP_USER === undefined) {
    // process.env.APP_USER does not exist (it's undefined)
    // Return a 401 (Unauthorized) HTTP code, with a JSON error message
    res.status(401).json({error: "You're not logged in. Go away!"});
} else {
    // username exists, carry on...
}
</pre>
Test this out by first trying to access a <code>POST</code> route without creating a <code>.env</code> file. Test this out in RESTer; you should get a 401 error and the "Go away" message as a response. Then, create a <code>.env</code> file with a <code>username</code> environment variable. The username can be anything, for example:
<pre>APP_USER=AdamAdams</pre>
You should now be able to access your POST route.
</li>
<li>As shown in the example with CORS, write the user-checking middleware in a separate module as a function and export it. Then, <code>import</code> it and <code>use()</code> it in the main server file by specifying the name of the function exported from the module.</li>
<li>Prevent all access to the <code>/users</code> group of routes (see Question 3) unless the username exists in <code>.env</code>. Use the same middleware for this.</li>
<li><strong>Advanced question:</strong> Modify your answer to the previous question so that, if the <code>/users</code> group of routes is requested, the middleware checks that the <code>APP_USER</code> username is <em>actually in the database</em> (use a SELECT statement to do this) and that the value of the <code>isadmin</code> column of this user is 1. In this way, only admin users can access the <code>/users</code> routes which, for data protection reasons, is probably a good idea!</li>
</ol>
</body>
</html>

