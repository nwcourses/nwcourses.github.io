<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Topic 2: Node.js and databases</title>
<link rel='stylesheet' type='text/css' href='../css/dfti0910.css' />
</head>
<body>
<div class="titlebox"><h1>Topic 2: Node.js and databases</h1></div>
<h2>Databases - revision</h2>
<p>You have already worked with SQL databases in your first year. As you
should remember from your databases module, data is stored in <em>tables</em> with <em>columns</em>, and we get data out of the database using <em>queries</em> . These queries are written in <em>Structured Query Language (SQL)</em>.</p>
<h2>Databases as a client-server system</h2>
<p>Database systems consist of two components, the <em>server</em> and
the <em>client</em>:
<br/>
<img src="../images/db1.png" alt="Database as client/server system"/></li>
<br />
<h3>The database server</h3>
<p>A database <em>server</em> is what we refer to when we informally use the term "database software". It is a continuously-running program which <em>listens</em> to SQL queries from clients, processes them and sends back a <em>response</em>; in this respect, a database server is just like any other server, including a web server.</p>
<p>Examples of database servers include:
    <ul>
    <li><strong>Free, open source</strong>: MySQL, PostgreSQL, MariaDB</li>
    <li><strong>Commercial</strong>: Microsoft SQL Server, Oracle</li>
    </ul>
</p>
<h3>The database client</h3>
<p>Users do not typically interact directly with the database server. Instead, they interact with a <em>database client</em> - a piece of software which communicates with the database server by connecting to it, sending SQL queries, and processing the response. When developing web applications, your software (for example, your Node.js server, or an Apache server running a language such as PHP) would act as the database client. Additionally, a wide range of administration software for database servers is available, allowing developers to control the database via a user-friendly interface. These include:
    <ul>
    <li>PHPMyAdmin (web-based interface to MySQL)</li>
    <li><code>mysql</code> command line tool (command-prompt-based interface to MySQL)</li>
    </ul>
</p>
<h3>Three-tier architecture</h3>
<p>Database-driven web applications adopt a <em>three-tier architecture</em>. This is because there are three layers: web browser (which the user interacts with), web server (e.g. Node.js or Apache/PHP), and database server.
The web server acts as the <em>server</em> with respect to the 
user's web browser, but the <em>client</em> with respect to the database server:
<br/>
<img src="../images/db2_language_independent.png" alt="Clients, servers, scripts and databases"/>
<br/>
</p>
<p>The general steps made by a web server application when connecting to a database server are:
<ol>
<li>Connect to the database</li>
<li>Send a query to the database</li>
<li>Receive the results from the database</li>
<li>Send the results, formatted in HTML, back to the browser</li>
</ol>
</p>
<h2>Installing and using a database</h2>
<p>Due to problems connecting to Goorm currently (meaning that it will be difficult to use MySQL), we are going to focus on <em>SQLite</em>. This is not a full client-server system (there is no SQLite server) but instead uses a simple flat file (with a <code>.db</code> extension) to store the data. Nonetheless, SQLite still allows you to use SQL to communicate with the database via Express routes, which is the basis of developing a database-driven web API.</p>
<h3>More on SQLite</h3>
<p><em>SQLite</em> (see <a href="http://www.sqlite.org">sqlite.org</a>)
is a simple on-board client-side database which does not require a full
database management system setup (like MySQL or Oracle) and its attendant client-server architecture. SQLite databases can be easily embedded into any Java application, whether that be a web application, a console application, a desktop GUI Java application or an Android app. SQLite databases are stored as simple files, with a <code>.db</code> extension. You can download SQLite <a href='https://www.sqlite.org/download.html'>here</a>. You can query and manipulate an SQLite database via the console-based <code>sqlite3</code> tool, documented <a href='https://www.sqlite.org/cli.html'>here</a> and downloadable <a href='https://www.sqlite.org/download.html'>here</a> along with the SQLite libraries. You can also upload a <code>.db</code> database to the online "fiddle" tool <a href='https://sqlite.org/fiddle/index.html'>here</a> and enter SQL statements to query and manipulate the database.</p>
<h2>Node and SQLite</h2>
<p>We are going to look now at how you can connect to an SQLite
database from Node.js. As you might guess from last week, there are various
modules available to do the job, including <code>better-sqlite3</code> which we will use as it is straightforward and, according to its developers, gives better performance than some alternatives. Documentation is available
    <a href='https://npmjs.com/package/better-sqlite3'>here</a></p>
<p>
To install, use <code>npm</code> as for last week from the command prompt (such as the goormIDE command prompt), e.g:
<pre>
npm install better-sqlite3 
</pre>
</p>

<p>Here is a simple example. You need to import the <code>Database</code> class from the <code>better-sqlite3</code> module and then create a <code>Database</code> object using your <code>.db</code> file:
<pre>
import Database from 'better-sqlite3';
const db = new Database('mydatabase.db'); 

// Rest of the code follows...
</pre>
</p>
<h3>REST - Representational State Transfer - An introduction</h3>
<p>It is a very common pattern in web development to develop a web API with
a series of endpoints which manipulate the database in various ways, using
HTTP methods appropriately for different operations. For example, if we
are <em>searching</em> the database with a SELECT query, we use a <em>GET</em>
method. If we are <em>updating</em> or <em>inserting</em> data, we use a
<em>POST</em> method and if we are <em>deleting</em> data, we use a 
<em>DELETE</em> method. We can set these methods up in Express easily:
<pre>
app.get('/endpoint1', ....);    // GET request
app.post('/endpoint2', ....);   // POST request
app.delete('/endpoint3', ....); // DELETE request
</pre>
We can also use various HTTP methods <em>from within our Express server</em> 
to signal different types of error, e.g.
    <ul>
    <li>404 Not Found - if we are trying to search for something which could
    not be found in the database;</li>
    <li>400 Bad Request - if the format of the HTTP request was invalid in
    some way;</li> 
    <li>500 Internal Server Error - if an internal error on the server
    occurs, for example the database server is not running.
    </ul>
We can send back different HTTP status codes from Express with the
<code>status()</code> method, eg.:
<pre>res.status(404);</pre>
This pattern, of:
    <ul>    
    <li>using API endpoints which logically represent the data we are trying
    to retrieve (e.g <code>/songs/Oasis</code> to represent all songs by
    Oasis);</li>
    <li>using HTTP methods appropriately depending on what operation is
    being performed;</li>    
    <li>and sending back appropriate HTTP status codes to indicate different
    types of error;</li>
    </ul>
is a key feature of the <em>REST</em> (Representational State Transfer)
pattern for developing web APIs. An API which follows these principles
(plus some others) is known as a REST API. (There is more to REST, the former Level 6 WAD module <a href='https://nwcourses.github.io/wad/wad2.html'>gives some information here</a>).</p>
<h3>Performing SQL queries with the better-sqlite3 module</h3>
<h4>SELECT</h4>
<p>The code below is a <em>snippet</em> of code showing a
route handler as part of an Express application. It performs an SQL 
statement to find all students with the last name matching the
<code>lastname</code> parameter to the Express route, so that for example:
<pre>https://url-of-your-server.example.com/students/Smith</pre>
would find all students with the last name Smith.
<pre>
app.get('/students/:lastname', (req, res) =&gt; {
    try {
        const stmt = db.prepare("SELECT * FROM students WHERE lastname=?");
        const results = stmt.all(req.params.lastname);
        res.json(results);
    } catch(error) {
        res.status(500).json({ error: error });
    }
});
</pre>
<p>We first create a <em>prepared statement</em> using the <code>prepare()</code> method of our database object. A prepared statement is a statement which has parameters <em>bound</em> to it, and then is <em>compiled</em> into a binary form which can be stored in memory and rapidly executed by the database. The advantage of a prepared statement is that once compiled, it can be rapidly executed again and again by the database if our application performs the same query multiple times. Prepared statements also prevent a certain type of security exploit known as <em>SQL injection</em>, in which a database can be compromised by the user entering fragments of SQL into a form which combine with existing SQL code in the JSP. We will look at SQL injection in more detail later in the module.</li>
<li>Note how the SQL contains placeholders for bound parameters, using question marks <code>?</code> We bind data to each placeholder when we execute the statement. To execute a SELECT statement we use the <code>all()</code> method of our prepared statement object, and pass the bound parameters as arguments. So here:
<pre>const results = stmt.all(req.params.lastname);</pre>
will bind the <code>lastname</code> parameter of the route to the first placeholder. The result will be that we query the database for all students with that last name.</p> 
<p>The <code>all()</code> method returns <em>an array of all matching rows from the database, as an array of JavaScript objects</em>. We send back that array as  <em>JSON</em>, using <code>res.json()</code>, which we saw last week.</p>
<p>Note also the use of a <code>try</code>/<code>catch</code> block. Those of who who have studied OODD will have seen this already. Basically we are <em>try</em>ing to do something, and if it fails, we <em>catch</em> the error in the <em>catch block</em>. So, if there was an error, we send back a JSON object containing an <em>error</em> property with a value of
the error that occurred, and also send back an HTTP status code of 500
(Internal Server Error) which, by convention, is used if the server
encountered an internal error which was not caused by a user mistake. 
</p>
<p>This version returns <em>all</em> students in the database. Note that in this case, we don't need to specify a parameter to the the query, so <code>stmt.all()</code> takes no arguments.
<pre>app.get('/students', (req, res) =&gt; {
    try {
        const stmt = db.prepare("SELECT * FROM students");
        const results = stmt.all();
        res.json(results);
    } catch(error) {
        res.status(500).json({ error: error });
    }
});
</pre></p>
<h4>UPDATE</h4>
<p>Performing an UPDATE statement uses the same approach. Here is a route which could be used to <em>buy a product with a given ID</em> by reducing its quantity in stock by one. <strong>Note how this route has a method of POST, following the REST principles discussed above.</strong>
<pre>
app.post('/products/:id/buy', (req, res) =&gt; {
    try {
        const stmt = db.prepare('UPDATE products SET quantity=quantity-1 WHERE id=?');
        const info = stmt.run(req.params.id);
        if(info.changes == 1) {
            res.json({success:1});
        } else {
            res.status(404).json({error: 'No product with that ID'});
        }
    } catch(error) {
        res.status(500).json({ error: error });
    }
});
</pre>
Note that we use <code>run()</code>, rather than <code>all()</code>, with a statement which <em>updates</em> the database.
We use a try/catch block, as for the <em>SELECT</em> example. Also, we check the <code>changes</code> property of the <code>info</code> object returned from the query. This contains the number of rows affected by the SQL statement. If one row was updated, we send back a JSON success message. If not, the reason will be that there is no product with that ID. By convention, following the principles of REST, if we cannot find what we are looking for in a route, we send back the HTTP status code 404 (Not Found).</p>
<h4>DELETE</h4>
<p>DELETE is similar to UPDATE. As we saw above, a route which results in the deletion of data makes use of the HTTP <em>DELETE</em> method.
<pre>
app.delete('/products/:id/buy', (req, res) =&gt; {
    try {
        const stmt = db.prepare('DELETE FROM products WHERE id=?');
        const info = stmt.run(req.params.id);
        if(info.changes == 1) {
            res.json({success:1});
        } else {
            res.status(404).json({error: 'No product with that ID'});
        }
    } catch(error) {
        res.status(500).json({ error: error });
    }
});
</pre>
Note how again we check the <code>changes</code> property of the results
to check whether it found the record to delete.</p>
<h4>INSERT</h4>
<p>Insertion is discussed below, as there is something else we need to 
consider first: <em>the nature of POST requests</em> and <em>how to send POST data to the server.</em></p>
<h3>POST requests</h3>
<p>With POST requests, we often need to <em>send data to the server</em>, for example when creating a new product in a products database for a shop, we might need to send the name, manufacturer and price. This is done by <em>embedding the data in the request body</em>, often as JSON, but also as key-value pairs. Last week we considered HTTP requests. Let's see
an example of an HTTP POST request with embedded data:
<pre>
POST /product/create HTTP/1.1
Host: www.solent-e-stores.com
Content-Type: application/json

{"name":"Corn Flakes","manufacturer":"Smith Emporium","price":1.29}  
</pre>
Note how we are sending <em>POST</em> data to <code>/product/create</code> and note how the HTTP <em>request</em> has a <code>Content-Type</code> of <code>application/json</code> (we covered MIME types last week). This is now telling the <em>server</em> (not the client) that what is being sent is JSON.</p>
<p>Note also how the <em>request body</em> begins after the headers, with a gap
of one line. Note here, how the request body contains a JSON object containing
details of a product.</p>
<p>How can we read the request body from an Express application? 
When you wish to access the request body in your routes, you use
the <code>req.body</code> object. Here is an example of a 
<code>/product/create</code> route which reads JSON from the request body
and performs an SQL INSERT statement with it:
<pre>
app.use(express.json()); // necessary to read JSON data from the request body

app.post('/product/create', (req, res) =&gt; {
    try {
        const stmt = db.prepare('INSERT INTO products(name, manufacturer, price) VALUES (?,?,?)');

        const info = stmt.run(req.body.name, req.body.manufacturer, req.body.price);
        res.json({id: info.lastInsertRowid});
    } catch(error) {
        res.status(500).json({ error: error });
    }
});
</pre>
Note how the <code>info</code> object has a <code>lastInsertRowid</code> property representing the primary key (ID) allocated to the new record. So if the operation was successful, we send back JSON containing the ID, which can then be used by the client.</p>
<h3>Testing HTTP request methods other than GET</h3>
<p>One question remains. How can you <em>test out</em> these methods?
With GET methods, it's simple (we did it last week); you simply request
the desired API endpoint in your browser and the appropriate route will
be executed. However, with other methods, such as POST and DELETE, it's more
difficult, as browsers always send GET requests when you type in a URL.</p>
<h4>Enter RESTer</h4>
<p>There are various third-party tools which can be used to test out APIs.
A particularly useful one, which those of you on Craig's OODD will have 
already been introduced to, is <em>RESTer</em>. This is a browser extension
which allows you to simulate HTTP requests and is available for
<a href='https://chrome.google.com/webstore/detail/rester/eejfoncpjfgmeleakejdcanedmefagga'>Chrome</a> and <a href='https://addons.mozilla.org/en-US/firefox/addon/rester/'>Firefox</a>. To install RESTer, visit either of these links and follow the instructions, and RESTer will be installed to your browser.</p>
<p>RESTer has an interface as shown below:
<br />
<img src="../images/rester1.png" alt="RESTer interface" />
<br />
Note how RESTer allows you to specify, amongst other things:
    <ul>
    <li>the HTTP method to use;</li>
    <li>the URL to request;</li>
    <li>the <em>headers</em> and <em>body</em> of the request.
    </ul>
In the example above, a GET request is being made to the URL <code>https://url_of_your_server.example.com/artist/Oasis</code>. Note how the response is shown below the controls, showing the status code, the response headers and the response body.</p>
<p>The screenshot below shows how you can add headers to the HTTP request by selecting the <em>Headers</em> tab. Here we have specified the <code>Content-Type</code> as <code>application/json</code>:
<br />
<img src="../images/rester2.png" alt="Setting content type in RESTer" />
<br />
You can also add data to the request body. This is shown below, note how we have added JSON describing a song. (Prize to anyone who can guess why I have chosen this particular song...)
<br />
<img src="../images/rester3.png" alt="Setting request body in RESTer" />
<br />
RESTer also allows you to test error conditions: if you supply invalid 
request data and your web API checks for this, then you will get a non-200
status code returned.</p>
<h2>Exercises</h2>
<ol>
<li>Clone <code>mysqlview</code> from GitHub. This is a very simple database viewer and editor which supports MySQL and SQLite, and can be used to view your database:
<pre>https://github.com/nickw1/mysqlview</pre>
I will demonstrate the use of this in class (it will be recorded)
</li>
<li>Use this <a href='wadsongs.db'>db file</a> for your database.
Develop a simple REST API in Node and Express with endpoints to: 
    <ul>
    <li>GET: search for all songs by a given artist;</li>
    <li>GET: search for all songs with a given title;</li>
    <li>GET: search for songs by artist AND title (i.e. both must match);</li>
    <li>GET: find a song with a given ID</li>
    <li>POST: buy a physical copy of song (decrease its quantity by 1)</li>
    <li>DELETE: delete a song with a given ID</li>
    <li>POST: add a new song; specify all columns in the database except the ID which is auto-created.</li> 
    </ul>
</li>
<li>Test the GET endpoints in the browser, <strong>and the POST and DELETE endpoints in RESTer. In particular, for "add a new song", you will need to specify the song as JSON in the request body in RESTer, and set the content type to <code>application/json</code></strong>; see above.</li>
<li><strong>More advanced</strong>: Create a <code>public</code> folder, and in it, create a static HTML page containing a field for the artist and a button. When the user clicks the button, some JavaScript <em>on the client</em> should run, to read the artist the user entered in the text field and redirect the user to the web API endpoint for searching by artist. In this client-side code, <code>window.location</code> to redirect the browser, e.g.
<pre>window.location = `https://url-of-your-server.example.com/.....`; // for you to complete!</pre>
Once you've done that, add a further two fields (for title an artist) and second button to the static HTML page, and add some further client-side JavaScript to redirect the user to the artist-and-title endpoint. <strong>For both questions, use Express to serve the static page. You can do this by adding the line:</strong>
<pre>app.use(express.static('public'));</pre>
This will tell Express to serve all content in the <code>public</code> folder as static pages. So to access the file <code>file.html</code> inside the <code>public</code> folder from the browser, you can access it via <code>https://url-of-your-server.example.com/file.html</code>.</li>
</ol>
</body>
</html>

