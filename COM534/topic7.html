<!DOCTYPE html>
<html>
<head>
<title>OODD Week 7 - Introduction to Compose Multiplatform</title>
<link rel='stylesheet' type='text/css' href='https://code.cdn.mozilla.net/fonts/fira.css' />
<link rel='stylesheet' type='text/css' href='../css/nwnotes.css' />
</head>
<body>
<header>
<h1>Object Oriented Design and Development</h1>
<h1>Topic 7: Introduction to Compose Multiplatform</h1>
</header>

<main>
<h2>Compose Multiplatform</h2>
<p><em>Compose Multiplatform</em> is a multi-platform framework to allow you to develop GUI applications across a range of platforms. Originally a framework for Android apps specifically (<em>Jetpack Compose</em>), it now supports a range of different platforms including common desktop platforms (Windows, Linux, Mac) as well as iOS.</p>

<h3>Declarative layouts</h3>

<p>Compose Multiplatform adopts a <em>declarative</em> approach to UI development. What does that mean? 
    <ul>
    <li> With a declarative approach, by contrast, we <em>declare</em> the layout by writing a series of Kotlin functions called <em>composable functions</em> and also specify the data within them by inserting that data directly into the layout where it's needed. We store that data in what is known as <em>state</em> and change the state in response to UI events, for example button clicks. Importantly, <strong>changing the state triggers an automatic re-rendering of the UI</strong>. </li>
    </ul>
</p>
<p>So, code for a declarative UI might look something like this (not real code):
<pre>
ScreenLayout = {
    currentName: StringStateVariable

    TextField { onKeyPress = { set currentName to TextField contents } }
    TextLabel { contents =  "Hello $currentName!" }
    Button { text : "Set name to blank", onClick = { currentName = "" } }
}
</pre>
Note how we store a name (that the user might enter) in a <em>state</em> variable called <code>currentName</code>. The TextLabel shows the message "Hello" plus the name from the state, the TextField allows the user to enter a new name, and the name is updated to the text field contents when a key is pressed while it's focused, and the Button clears the name to a blank string when it's clicked. Note how the TextField <em>tracks the state</em>, so that whenever the state is updated, the TextField contents automatically update.</p>

<h2>Getting started with Compose Multiplatform</h2>
<p>There are two main ways of starting up a Compose Multiplatform project:
    <ul>
    <li>Create a Compose Multiplatform project on IntelliJ IDEA (recommended on your own computer);</li>
    <li>Use the Compose Multiplatform Wizard on Android Studio (recommended on the university computers).</li>
    </ul>
We will look at these one by one. More information on setting up a Compose Multiplatform project can be found on <a href='https://github.com/JetBrains/compose-multiplatform-desktop-template'>the JetBrains GitHub repositories.</a></p>
<p>The Nutanix virtual machine for this module is <strong>not</strong> recommended for working with Compose Multiplatform, as it runs very slowly and certain setups produce obscure errors.</p>
<h3>On IntelliJ IDEA</h3>
<p>Load up IDEA:
<br />
<img src="../images/composeMultiplatform1.png" alt="Selecting a Compose Multiplatform project in IDEA" />
</p>
<p>Create a project and ensure you select <em>Compose for Desktop</em> as the project type. An <strong>IMPORTANT</strong> point is that you need to choose a version of Java - remember that Kotlin runs on the <em>Java Virtual Machine</em>. The Java Development Kit (JDK) is required to compile Kotlin into Java bytecode. The default version is likely to be 22 or 23 but these may require an update to the <em>Gradle</em> build tool (see below) (see below). So your choices are:
	<ul>
	<li>Use the most up-to-date version of Java and upgrade your Gradle;</li>
	<li>Use an older version of Java.</li>
	</ul>
</p> 
<p>If using up-to-date Java, you may see this error come up:
<br />
<img src="../images/composeMultiplatformGradleUpgrade.png" alt="Prompt to upgrade Gradle" />
</p>
<p>This is because Java Development Kit (JDK) 22 requires an updated version of <em>Gradle</em>. What is Gradle? It is a <em>build tool</em>, used to build projects from source and handle dependencies (such as Compose Multiplatform). Compose Multiplatform uses Gradle to build apps. The Gradle website can be found <a href='https://gradle.org'>here</a>. You can choose to either <em>upgrade Gradle</em> to use a compatible version with your JDK, or <em>downgrade the JDK</em>. If you choose to upgrade Gradle to version 8.5, it  will download version 8.5 (warning! this might take some time).</p>
<h4>Downgrading Java</h4>
<p>As an alternative to upgrading Gradle you can use an older JDK. When you create a project, you will be asked to choose a version of the JDK. If the version you want is not present, you can download an alternative version by selecting "Download JDK" as shown below.</p>
<p><img src="../images/choosejdk.png" alt="Choose a JDK from IDEA" /></p>
<p>If you choose to download a JDK you will be prompted as shown below. You need to choose the Java version and it will offer a list of JDKs for that version of Java. The older versions are likely to be Amazon's Java distribution called Corretto, but these are fully compatible with the Oracle version.</p>
<p><img src="../images/downloadjdk.png" alt="Choose a JDK from IDEA" /></p>
<p>Corretto 21 or 20 should work fine.</p>
<h3>On Android Studio</h3>
<p>On the university computers, you are strongly recommended to use use <em>Android Studio</em> with the <em>Kotlin Multiplatform Wizard</em> - on the main PC, <strong>not</strong> Nutanix. Android Studio (which is installed at the university) is an IDE aimed at Android development, however you can also use it for Compose Multiplatform development even if you are just developing for desktop.</p>
<p>If on your own computer, you can use IntelliJ IDEA as described above, but if you want to use Android Studio, first download it and install: see <a href='https://developer.android.com/studio'>here</a>.</p>
<p>The Kotlin Multiplatform Wizard auto-generates a project with the correct settings for building successfully. Generate the project using the Wizard, and download it, at <a href='https://kmp.jetbrains.com'>kmp.jetbrains.com</a>. You choose your target platforms: for our purposes we only need <em>Desktop</em> so select Desktop and unselect Android and iOS.</p>
<p>Unzip the wizard-generated project and copy the project folder to your <code>AndroidStudioProjects</code> folder in your home folder. This is generated by Android Studio but may not exist if you have not run Studio yet, so if it's not present, create this folder.</p>
<p>Then open the project. Load Android Studio, select "Open" and open the project (in my case it is called <code>KMPWizard1</code>, in your case give it whatever name you specified in the wizard):
<br />
<img src="../images/kmpWizardOpen.png" alt="Opening the Kotlin Multiplatform Wizard generated project" />
</p>
<p>A full information page about building and running wizard-generated Kotlin Multiplatform projects is available <a href='https://www.jetbrains.com/help/kotlin-multiplatform-dev/compose-multiplatform-create-first-app.html'>from Jetbrains</a>.</p>
<p>It will take some time to build. Once it's built it's <strong>important you run it the correct way</strong>, using the <code>composeApp:run</code> Gradle task. Pressing the green "run" button on its own will not work, failing with a <code>Cannot find MainKt</code> error (i.e. it cannot find your <code>main()</code>). You should follow the <a href='https://www.jetbrains.com/help/kotlin-multiplatform-dev/compose-multiplatform-create-first-app.html#run-your-application-on-desktop'>Run your application on desktop</a> instructions carefully - these explain how you can specify the correct run configuration.</p>

<h2>Developing with Compose Multiplatform</h2>
<p>We will now start looking at the structure of a Compose Multiplatform application. If you look at the generated code (look at <code>src</code>-<code>main</code>-<code>kotlin</code>-<code>Main.kt</code> in IntelliJ IDEA - Gradle uses a different folder structure for projects) it will look something like this:
<pre>
import androidx.compose.material.Button
import androidx.compose.material.MaterialTheme
import androidx.compose.material.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.window.Window
import androidx.compose.ui.window.application

@Composable
fun App() {
    var text by remember { mutableStateOf("Hello, World!") }

    MaterialTheme {
        Button(onClick = {
            text = "Hello, Desktop!"
        }) {
            Text(text)
        }
    }
}

fun main() = application {
    Window(onCloseRequest = ::exitApplication) {
        App()
    }
}
</pre>
What's going on here?
    <ul>
    <li>You will notice that, as always, there is a <code>main()</code> function which is the starting point of our application. Note, however, the different syntax:
<pre>fun main() = application { ...</pre>
rather than
<pre>fun main() { ...</pre>
What's this doing? <code>application()</code> is part of the Compose API. Compose Multiplatform, like other UI libraries, needs to work in an <em>asynchronous</em> (multitasking) manner,  e.g. the user can continue to interact with the UI while the application is performing some processing. However, the console is a purely synchronous environment. The <code>application()</code> function essentially allows your <code>main()</code> to launch asynchronous code. See <a href='https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html'>here</a> and <a href='https://github.com/JetBrains/compose-multiplatform-core/blob/jb-main/compose/ui/ui/src/desktopMain/kotlin/androidx/compose/ui/window/Application.desktop.kt'>here</a>. We will look at this topic in more detail in Mobile Application Development when we examine <em>coroutines</em>.</li>
<li>We then create a <code>Window</code> object. As you can probably guess, this represents a UI window. Note how we give the <code>Window</code> an <code>onCloseRequest</code> parameter (Kotlin has named parameters, like Python, i.e. we do not need to pass in values for all parameters or pass them in order, we can refer to them by name). This parameter is set equal to the in-built function <code>exitApplication</code> which closes the application down. So, when the user closes the window, the application will exit.</li>
<li>Note how we then specify a lambda function associated with <code>Window</code> and inside this lambda we launch <code>App()</code>. <code>App()</code> is a <em>composable</em> representing our application.</li>
</ul>

<h3>Composable functions</h3>

<p>In Compose Multiplatform, we define each UI component as a <em>composable function</em>. Composable functions typically represent reusable groups of UI elements which work together, e.g. a login composable function could contain username and password fields and a button which logs the user in.</p>

<h4>Example of a composable function</h4>

<p>In the auto-generated code you will find an <code>App()</code> composable. We will cover what this auto-generated code does later, but for now, delete the pre-generated <code>App()</code> and replace it with this new <code>App()</code>:
<pre>@Composable
fun App() {
    Text("Hello Compose World!")
}</pre>

Note how we create a function <code>App()</code> labelled with the <em>annotation</em> <code>@Composable</code>. This turns <code>App()</code> into a composable. Annotations are meta-language instructions which are converted by a pre-processor into more complex Kotlin or Java code. The <code>App</code> function contains a <code>Text</code> composable which displays a Hello World message.</p>


<h4>Writing custom composables</h4>

<p>So far we have just filled the default <code>App()</code> composable. However we can create our own composables, separate to <code>App()</code>, and include them within <code>App()</code> to develop a more complex UI. For example:
<pre>@Composable
fun HelloWorld() {
    Text("Hello World fron the Custom Composable!")
}

@Composable
fun App() {
    HelloWorld()
}</pre>
Note how we include <code>HelloWorld</code> in the <code>App</code> composable.</p>

<h4>A more complex composable function</h4>
<pre>
import androidx.compose.foundation.layout.Column // new import

@Composable
fun TwoTexts() {
    Column {
        Text("Hello World!")
        Text("Welcome to Compose Multiplatform Development")
    }
}
</pre>
<p><em>Note that in all these examples, where an import is marked with <code>// new import</code> you need to add it to the list of imports at the top of the file which is auto-generated when you set up a Compose Multiplatform project.</em></p>
<p>This example creates a composable function with <em>two</em> UI elements: two <code>Text</code> elements arranged vertically. The vertical layout is defined with <code>Column</code> which arranges all the elements within it in a vertical column. There is also <code>Row</code> which arranges all elements within it horizontally.</p>

<h4>Controlling the appearance of UI elements</h4>

<p>We can control the appearance of a UI element by setting various parameters on the element. For example we can control colour, font style (normal or italic), font weight (normal or bold) and font family. Here is the previous example with the appearance of the <code>Text</code> elements styled:
<pre>
import androidx.compose.ui.text.font.FontStyle // new import
import androidx.compose.ui.text.font.FontFamily // new import
import androidx.compose.ui.text.font.FontWeight // new import
import androidx.compose.ui.graphics.Color // new import

@Composable
fun TwoTextsStyled() {
    Column {
        Text("Hello World!", color = Color.Red, fontStyle=FontStyle.Italic, fontFamily=FontFamily.Serif)
        Text("Welcome to Compose Multiplatform Development", fontWeight=FontWeight.Bold)
    }
}</pre>
Hopefully much of this is fairly clear but a few points:
<p>Note how each argument to <code>Text</code> is labelled with an identifier, e.g. <code>fontStyle=...</code>. As stated above when discussing the <code>Window</code>, this is an interesting feature of Kotlin which is also seen in Python; we do not have to pass in the arguments to a function in order if we label them. So <code>Text()</code> for example has <code>color</code> and <code>fontStyle</code> parameters and these can be specified in any order as long as they are labelled.</p>
<h4>Passing in Parameters</h4>
<p>We can pass <em>parameters</em> into our composables and use those parameters to control how they display, e.g this composable will display a given message a given number of times in a column by using a loop to include a <code>Text</code> the given number of times displayed in a given colour (black by default):</p>
<pre>
@Composable
fun MultiMessage(message: String, nTimes: Int, colour: Color = Color.Black) {
    Column {
        for(i in 1..nTimes) {
            Text(message, color=colour)
        }
    }
}
</pre>
<p>This could then be included in your App as follows:</p>
<pre>@Composable
fun App() {
    MultiMessage("Hello Compose World!", 3, Color.Blue)
}</pre>
<h3>Events and State</h3>

<p>Many UI elements in Compose Multiplatform come with an accompanying <em>event handler</em>, which runs when the user interacts with it. Examples include <code>Button</code> (which comes with a click handler) and <code>TextField</code> (which comes with an <code>onValueChange</code> event handler to handle the text in the text field changing). Event handlers are typically specified as <em>lambda functions.</em> We will now start building a <code>GreetingBox</code> which allows the user to enter their name and displays "Hello" plus their name.
<pre>
@Composable
fun GreetingBox() {
    Column {
        TextField(value = "Enter your name: ", onValueChange={/* event handler */ })
        Text("Greeting will go here")
    }
}
</pre>
Note how the <code>TextField</code> takes two compulsory arguments, the default text to place inside the text field, and the <code>onValueChange</code> event handler which runs when the user enters text (a lambda function).  Note that here we have used named parameters in the <code>TextField</code>, we do not need to do this (as the value and <code>onValueChange</code> event handler are the first two parameters) but have added them for clarity.</p>
<p>How can we actually display a greeting in the <code>Text</code> corresponding to the name that the user entered, though? Or, in general, how can we dynamically update a Compose UI? We use composable <em>state</em> to do this. In event handlers, we update state variables, and then we include that state in other UI elements. <strong>When the state updates, the UI will automatically be refreshed.</strong> If you have worked with <em>React</em> in web development, you will recognise this pattern.</p>

<p>So how do we setup state? We have to declare a variable in this way, inside the Composable:
<pre>var name by remember { mutableStateOf("") }</pre>
The use of <code>by remember</code> creates a state variable called <code>name</code> which is initialised within the provided lambda to a blank string "". We will examine the meaning of this code, specifically <code>by</code>, in more detail in the Mobile Application Development module, but for now you just need to know that it initialises <code>name</code> so that it can act as a state variable and cause the composable to redraw itself when it changes. 
</p>
<p>We can then insert the state variable within the UI where we like, e.g:
<pre>
import androidx.compose.runtime.remember // new import
import androidx.compose.runtime.mutableStateOf // new import
import androidx.compose.runtime.setValue // new import
import androidx.compose.runtime.getValue // new import

@Composable
fun GreetingBox() {
    var currentName by remember { mutableStateOf("") }
    Column {
        TextField(value=currentName, onValueChange={ currentName = it })
        Text("Hello $currentName!")
    }
}
</pre>
<ul>
<li>
Note how we set the <code>value</code> of the <code>TextField</code> to the state variable so that the text field is always in sync with the current value of the state variable.</li>
<li>The <code>onValueChange</code> event handler lambda for the <code>TextField</code> takes the new text within the text field as its one and only parameter (<code>it</code>) so, in the event handler, we <em>update the state variable <code>currentName</code></em> to the current text in the text field. Then, in the <code>Text</code> element, we include the state variable in our greeting, so the greeting will always sync with what the user entered in the text field.</li>
</ul>

<h3>Buttons</h3>

<p>Buttons in Compose Multiplatform are quite easy to setup. Here is an example:
<pre>
import androidx.compose.material.Button // new import

Button ( 
    onClick = { /* make something happen when the user clicks the button */ }
) {
    // Text as a child component of the button
    Text("Click me!")
}
</pre>
The <code>Button</code> function takes a number of parameters including an <code>onClick</code> event handler, for which we usually pass a lambda. After specifying the other parameters of <code>Button</code> we specify a lambda containing the text to display on the button as a <code>Text</code> component, which will make the <code>Text</code> a child component of the button and therefore make the text appear on the button.</p>
<h2>Exercises</h2>
<ol>
<li>Try out "Hello World" and the "TwoTexts" and "TwoTextsStyled" examples, above.</li>
<li>Write a complete working app including a composable to allow the user to enter a name via a <code>TextField</code>. The composable should greet the user by name in a <code>Text</code>, with a message such as <strong>Hello John!</strong></li>
<li>In the same app, write a composable to implement a counter. The composable should include a state variable to hold the counter's current value (initialise it to 0) plus a <code>Text</code> containing the counter's value and a button which, when pressed, increases the counter by one. Display the counter's value in red.</li>
<li>In the same app, write a composable to convert feet to metres. One foot is 0.305 metres. The user should be able to enter a value in feet, and the result should be displayed in metres. Give your <code>TextField</code> a <code>label</code> parameter, this should be set equal to a lambda containing a <code>Text</code> element with the label "Enter feet", i.e.:
<pre>TextField(feetState, onValueChange={...}, label={ Text("Enter feet:") }) ...</pre>
    <ul>
    <li><strong>Hint!</strong> Store the current feet as a <code>String</code> state variable and use <code>toDoubleOrNull()</code> (see below) when you need to do the conversion. This will be easier than storing the feet as a <code>Double</code> state variable. </li>
    <li><strong>Hint 2:</strong> the <code>toDoubleOrNull()</code> method of <code>String</code> will return a <code>null</code> if the user enters something which is not a number (e.g. letters). You can make use of this together with the Elvis operator to set the value to 0 if the user enters a non-numeric value for the feet. You can also use it to display an error if the user enters a non-numeric value - have a go at this if you finish everything else.</li>
    </ul>
</li>
</ol>
</body>
</html>
