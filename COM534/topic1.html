<!DOCTYPE html>
<html><head>
<title></title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel='stylesheet' type='text/css' href='https://code.cdn.mozilla.net/fonts/fira.css' />
<link rel="stylesheet" type="text/css" href="../css/nwnotes.css">
</head><body>

<header>
<h1>Object Oriented Design and Development</h1>
<h1>Week 1: Introduction to Kotlin</h1>
</header>

<main>
<h2>Introduction</h2>

<p>So far on your course you have been introduced to the fundamentals of programming using Python. You have learnt about variables, loops, conditional statements, arrays and functions as well as <em>object-oriented programming</em>.
As you saw last year, object-oriented (OO) programming
involves writing code to represent real world <em>objects</em> such as a student, a car, players and enemies in games, or graphical user interface elements such as windows and buttons. As you will hopefully see in this
module, once you have learnt it, OO programming leads to more readable, more maintainable code.</p>

<p>Object-oriented programming can be used in many languages, such as Python, JavaScript, Java, or C++. An increasingly popular OO language, however, is <em>Kotlin</em>, and we will use Kotlin in this module. This is for a couple of reasons: Kotlin allows you to use contemporary programming styles easily, and Kotlin is the main language for Android development (which many of you will do in Semester 2).</p>

<p>Furthermore, with Kotlin, you can develop applications using a mix of Kotlin and <em>Java</em>, a very commonly-used object-oriented language. Both Kotlin and Java allow you to develop <em>cross-platform</em> applications: you can write a Kotlin/Java program on Windows and the same program will work on other
operating systems such as Linux or Mac OS X. </p>

<p>When developing applications, we can use <em>compiled</em> or <em>interpreted</em> approaches, or a mix of the two.

    <ul>
    <li>A <em>compiled</em> language is a language which is converted from source code into
    <em>machine code for the machine's CPU, in an executable format understandable by the machine's
    operating system</em>. This conversion is done by a piece of software known as a <em>compiler</em>.
    For example, on a Windows/Intel system, Intel machine code instructions would
    be stored in a .EXE file. On a Linux/Intel system, Intel machine code instructions would be stored
    in a Linux executable file, which has a different format to an .EXE but still contains Intel 
    instructions. On a smartphone with an ARM processor, ARM machine code instructions would
    be generated. C++ is an example of a compiled language. 
    You write C++ code and then <em>compile it into machine code</em> for the target CPU and operating system.
    Machine code is a <em>binary</em> format: a series of bytes which mean something to a CPU but cannot be
    read in a text editor. Kotlin can also be used as a pure compiled language via Kotlin/Native.</li>
    <li>An <em>interpreted</em> language is a language in which each line of code is read by a piece of 
    software known as an <em>interpreter</em> at <em>run time</em>, i.e. when you run the program.
    Interpreted languages are slower than compiled languages. With a compiled language, you run the
    executable which contains machine code, and machine code is directly understood by the CPU.
    With interpreted languages, the process of interpreting each line of code at run time is a slow one
    in comparison to the CPU executing instructions that it understands directly. On the other hand,
    interpreted languages will run on any machine upon which an interpreter is installed, so they are more portable. They are easier to debug, as you can simply edit the code: with compiled languages, you
    need to compile again, and if the machine code generated by the compiler contains certain types of errors
    (e.g. trying to add an element to an array outside its bounds) there is the risk that the computer will
    crash.</li>
<li>A third approach, commonly used with Kotlin, uses <em>bytecode</em> and a <em>virtual machine</em>. This does not exactly fit into either category, but instead adopts a hybrid approach. You 
<em>compile</em> a program, but it is not compiled into native machine code. Instead, it is compiled into a format known as <em>bytecode</em> which can be run on a <em>virtual machine</em>: a piece of software which <em>interprets</em> the bytecode. Thus it is a combined compiled/interpreted approach: the original source code is compiled into bytecode, and the bytecode is then interpreted by the virtual machine. Thus it combines the advantages of the two approaches:
    <ul>
    <li>The bytecode will run on any device upon which the virtual machine is installed, thus it is cross-platform;</li>
    <li>Because it is a compact, machine-friendly format, bytecode can be read by virtual machines faster than interpreters in pure interpreted languages can read text files of source code. 
    </ul>
A commonly-encountered virtual machine is the <em>Java Virtual Machine (JVM)</em>, named after the Java programming language. This is used by both Java and Kotlin. The JVM is part of the <em>Java Runtime Environment (JRE)</em>. The result is that <em>any computer with the JRE installed</em> can read bytecode for the Java Virtual Machine. So you can distribute such bytecode to Windows, Linux or Mac systems, and as long as they have the JRE installed, they will all be able to run your program.  
<br />
<br />
This is also the reason why you can mix Java and Kotlin in one application. You can write part of the application in Java and part in Kotlin, and because both compile to Java bytecode, the application will work as a complete whole.</li>
</ul>
<p>The diagram below compares a standard compiled language and a language making use of bytecode. 
<br />
<img src="../images/compiled_vs_bytecode.png" alt="Fully compiled language vs. JVM language" /> <br />
</p>
<h3>Key features of Kotlin</h3>

<p>Kotlin, developed by JetBrains (the developers of PyCharm and IntelliJ IDEA) is based on the Java programming language but also contains features of Python and JavaScript. With Kotlin you can develop object-oriented applications, and we will be focusing mostly on object-oriented development in this module. However it also allows you to use other development styles, such as the increasingly-popular <em>functional</em> programming.</p>

<p>Some features of Kotlin include:

<ul>
<li><em>Null safety</em> which prevents unintended use of <code>null</code> variables (equivalent to <code>None</code> in Python)</li>
<li><em>Type inference</em>: type of variables can be inferred by what they
are initialised to, so you don't need to explicitly declare the data type</li>
<li><em>Lambda functions</em>: anonymous functions which can be passed as
arguments to other functions (similar to arrow functions in JavaScript)</li>
<li><em>Data classes</em>: concisely create classes which represent data and
do not need methods</li>
<li><em>Extension functions</em>: add a single function (method) to an
existing class without needing to subclass it</li>
<li><em>Coroutines</em>: a lightweight approach to multi-tasking</li>
</ul>

<h2>Basic Kotlin coding</h2>
<h3>Hello World in Kotlin</h3>
<ul>
<li>Here is Hello World in Kotlin:
<pre>fun main () {
    println("Hello World!")
}
</pre>
</li>
<li>Note that in Kotlin, we define a <em>main function</em> (<code>fun</code> is the Kotlin keyword to indicate a function). The main function is called <code>main()</code> and is the entry point of the application. If you do not provide a <code>main()</code> function, the Kotlin runtime environment will be unable to work out where your program starts. You may be familiar with this concept if you have used languages such as C or C++ in the past.</li>
<li><code>println()</code> prints to the console, just like <code>print()</code> in Python</li>
</ul>
<h3>Data types in Kotlin</h3>
<p>A difference between Kotlin and Python is that Kotlin is a <em>strongly typed</em> language. What does this mean?  Whereas in Python, a variable can contain different data types, in Kotlin a variable can contain only <em>one</em> <strong>data type</strong> throughout its lifetime. By data type, we mean integer, floating-point, string and so on. Kotlin has the following data types (see <a href='https://kotlinlang.org/docs/basic-types.html'>the documentation</a>).
    <ul>
    <li><code>Boolean</code>: represents a boolean, i.e. true or false, value. Expressions return boolean values. Note that in Java, unlike in Python, <code>true</code> and <code>false</code> are <em>lower case</em>.</li>
    <li><code>Byte</code>: represents a single byte of data. Can hold the values 0 to 255.</li>
    <li><code>Char</code>: represents individual characters such as 'a', '!' or '$'. You will have met the
    <em>ASCII character set</em> where the values between 0 and 127 represent single characters
    (letters, numbers and punctuation from American English). An extended version, covering values 0 to 255, accounts for Western European characters (French, German etc as well as currency symbols such as the pound and the euro). However, the <code>Char</code> data type in Kotlin is designed to hold characters from international character sets such as Greek, Cyrillic (used in many Eastern European languages), Chinese or Arabic and therefore <code>Char</code> occupies <em>two bytes</em> in Kotlin. The two-byte system for representing characters is called <em>Unicode</em>.</li>
    <li><code>Short</code>: represents smaller whole numbers (16 bits or two bytes) in situations where memory is limited. 
    <li><code>Int</code>: represents an integer (a whole number). Occupies four bytes (32 bits). 
    Can hold positive and negative values, and therefore can store values from -2<sup>31</sup> to +2<sup>31</sup>-1 (31 bits for the number, 1 bit for the sign).</li>
    <li><code>Long</code>: represents larger whole numbers. Occupies eight bytes (64 bits). Again can hold positive
    and negative values, and therefore can store values from -2<sup>63</sup> to +2<sup>63</sup>-1.</li>
    Occupies two bytes (16 bits). Again can hold positive
    and negative values, and therefore can store values from -2<sup>15</sup> to +2<sup>15</sup>-1
    (-65536 to +65535)</li>
    <li><code>Float</code>: represents floating-point numbers. Occupies four bytes (16 bits). Recommended where memory is short
    but due to the relatively low precision, not recommended for applications such as 
    scientific and financial data.</li>
    <li><code>Double</code>: represents double-precision floating-point numbers. Occupies eight bytes (64 bits).
    Recommended for operations where high precision is vital, such as scientific and financial data.</li>
    <li><code>String</code> and <code>Array</code>s (of various types)</li>
    </ul>
</p>
<p>An important feature of Kotlin is that <em>all data types are objects</em>, even integers. We will look at the consequences of this later.</p>
<h3>Variables example</h3>
<ul>
<li>This example shows some aspects of how variables work in Kotlin:
<pre>fun main () {
    // Declare a as an Int. "val" means it is immutable (cannot be changed)
    val a: Int = 3

    // Type inference: "b" is an Int because it is initialised to an Int
    val b = 4
    
    // "c" is a "var", which means it can be changed
    var c = 5    

    // increase "c" by one
    c++

    // this would give a compiler error as "b" is immutable
    // b++

    // this would also give a compiler error as "c" is implicitly an Int
    //c = "A String"

    // Some other data types
    val d = 12345678L // Long, because it ends with L
    val pi = 3.141592654 // Double, the default for floating-point numbers
    val f = 1.23f // Float
    val str = "Hello" // String


    // Print them out. Note how we can embed variables in a string
    // by preceding them with '$'
    println("a is $a, b is $b, c is $c, d is $d, f is $f, pi is $pi, str is $str")
}
</pre>
</li>
<li>Note how we use <code>val</code> for immutable (unchanging) variables,
and <code>var</code> for mutable variables (those which can change)</li>
<li>Note how the type of a variable can be <em>inferred</em> by what value
we assign it to, in all variables above apart from "a", we do not declare
the type</li>
<li>Nonetheless the variables are <em>strongly typed</em>. Once you have declared a variable, you can <em>only</em> store data of that type in the variable, unlike Python. So, we cannot place a String in the variable <code>c</code> in the above example.</li>
<li>See <a href="http://kotlinlang.org/docs/reference/basic-types.html">here</a> for details on Kotlin data types</li>
</ul>
<h3>Loops in Kotlin</h3>
<ul>
<li>The program below shows some examples of basic loops:
<pre>fun main (args: Array&lt;String&gt;) {
    // Count from 1 to 10
    for (i in 1..10) {
        println(i)
    }

    // Count from 1 to 9 ("until" discounts 10 itself)
    for(j in 1 until 10) {
        println(j)
    }

    // count from 1 to 9 in steps of 2
    for(k in 1..9 step 2) {
        println(k)
    }
}
</pre>
</li>
<li>Note the syntax <code>1..10</code>. This is called a 
<em>range expression</em>. It returns a <code>Range</code> object representing the
range of numbers 1 to 10.</li>
<li>Note also the difference between the first two examples; 
<em>until</em> is a function which
returns a Range from the initial number up to, but
<em>not including</em>, the final number
    <ul>
    <li>So the second loop will only count from 1 to 9</li>
    </ul>
</li>
<li>We also have the standard <code>while</code> loop too, which is very like the equivalent in JavaScript</li>
<li>See <a href="http://kotlinlang.org/docs/reference/control-flow.html">
here</a> for full documentation on loops</li>
</ul>
<h3>Conditional statements in Kotlin</h3>
<ul>
<li>The program below shows some examples of conditional statements in
Kotlin:
<pre>fun main (args: Array&lt;String&gt;) {
    println("Enter your name:")
    val n = readln()
    if (n == "Linus Torvalds") {
        println("You invented Linux")
    } else {
        println("You didn't invent Linux")
    }

    println("Enter your grade:")
    val grade = readln()
    when(grade) {
        "A" -&gt; println("First")
        "B" -&gt; println("2.1")
        "C" -&gt; println("2.2")
        "D" -&gt; println("Third")
        "F" -&gt; { 
            println("Fail")
            println("Please resit in the summer.") 
        }
        else -&gt; println("Invalid grade $grade.")
    }
}
</pre>
</li>
<li>Note how if/else is similar to JavaScript</li>
<li>The <code>when</code> statement is specific to Kotlin though is similar to <code>switch</code> in other languages.</li>
<li>Note the use of <code>else</code> inside <code>when</code> to handle unmatched
conditions (e.g. here, if the grade is not A, B, C, D or F)</li>
</ul>
<h3>Conditional expressions</h3>
<ul>
<li>An important difference in Kotlin compared to many other languages is that conditionals can be used as <em>expressions</em>, i.e. they can return a value
which can be assigned to a variable</li>
<li>eg. 
<pre>fun main (args: Array&lt;String&gt;) {
    println("Enter your name:")
    val n = readln()

    // "msg" contains the result of the if statement
    val msg = if (n=="Linus Torvalds") "You invented Linux" else "You didn't invent Linux"
    println(msg)

    println("Enter your grade:")
    val grade = readln()

    // "degree" contains the result of the when statement
    val degree = when(grade) {
        "A" -&gt; "First" // Return "First" when grade is "A"
        "B" -&gt; "2.1" // Return "2.1" when grade is "B"
        "C" -&gt; "2.2"
        "D" -&gt; "Third"
        "F" -&gt; "Fail"
        else -&gt; "Invalid grade $grade."
    }
    println("Degree awarded: $degree.")
}
</pre>
</li>
<li>Note in this example how we store the result of the <code>if</code>
statement in the variable <code>msg</code>
    <ul>
    <li>...so that <code>msg</code> wil contain either <em>You invented Linux</em>
    or <em>You didn't invent Linux</em>, depending on the name typed in</li>
    </ul>
</li>
<li>Also notice how the <code>when</code> statement similarly returns a value,
i.e. "First" when the grade is "A", "2.1" when the grade is "B", etc. </li>
</ul>
<h3>Basic arrays, including for-in and if-in</h3>
<ul>
<li>Arrays are available in Kotlin, like most other languages</li>
<li>The <code>in</code> keyword in Kotlin allows us to do loops
with arrays and easily work out if a value is in an array: this is the same idea as in Python.</li>
<li>
<pre>fun main (args: Array&lt;String&gt;) {
    val langs = arrayOf("Python", "Java", "JavaScript", "PHP", "Kotlin")
    println("Languages you are learning at university:")
    for(curLang in langs) {
        println(curLang)
    }
    println("Please enter a programming language:")
    val lang = readln()
    val msg = if(lang in langs) "learning" else "not learning"
    println("You are $msg $lang at university.")
}
</pre>
</li>
<li>Note the use of the if statement as an expression again
(<code>if(lang in langs)...</code>)</li>
<li>Next time we will cover some additional features of arrays, and
lists</li>
</ul>
<h3>Nullability</h3>
<ul>
<li>In Kotlin, the value <code>null</code> is used to indicate "no value", rather like <code>None</code> in Python</li>
<li>A common error in programming is to unintentionally use a null variable, because you expect it to contain something</li>
<li>One of the really useful features of Kotlin is <em>null safety</em></li>
<li>With Kotlin, you can declare a variable to either be nullable or
non-nullable</li>
<li>Non-nullable variables will produce a <strong>compiler error</strong>
if you attempt to store 'null' in them</li>
</ul>
<h4>Non-nullable variables</h4>
<ul>
<li>By default, given data types (String, etc.)
are <em>non-nullable</em></li>`
<li>So this code will not compile, beacuse we declare <em>s</em> as a
non-nullable String and attempt to assign null to it
<pre>fun main (args: Array&lt;String&gt;) {
    var s: String = null
    println(s.length);
}
</pre>
</li>
</ul>
<h4>Nullable variables</h4>
<ul>
<li>What about cases where we want the variable to be nullable?</li>
<li>For example, a collection of data which doesn't exist until we open 
a file and read it in from the file</li>
<li>In this case, we <em>explicitly declare the variable as nullable</em>
by adding a question-mark <em>?</em> to the data type</li>
<li>So, will this code successfully compile?
<pre>fun main (args: Array&lt;String&gt;) {
    var s: String? = null
    println(s.length);
}
</pre>
</li>
</ul>
<h4>The safe-access operator</h4>
<ul>
<li>The answer is <em>no</em>, because even though we declared <em>s</em>
as a nullable string, we then try to access the length of a String object
which is null</li>
<li>In Java this type of operation would throw a NullPointerException</li>
<li>Kotlin's null-safety forces you to deal with this using the 
safe-access operator, <em>?.</em></li>
<li>Here is the previous example, rewritten to use the safe-access operator:
<pre>fun main (args: Array&lt;String&gt;) {
    var s: String? = null
    println(s?.length);
}
</pre>
</li>
<li>Here, due to the safe-access operator, we will only access the length
if "s" is not null</li>
</ul>
<!-- move this to later?
<h4>A practical example, and introducing Elvis</h4>
<ul>
<li>The previous example was to illustrate the nullable concept only, and 
obviously does not do anything interesting</li>
<li>This example shows a more practical use of the safe-access operator;
note that <em>readLine()</em> returns a nullable String (<em>String?</em>):
<pre>fun main (args: Array&lt;String&gt;) {
    println("Please enter a number:")
    val str1 = readLine() // this might return null, e.g. if we are in a non-console environment

    // Elvis: Set a EITHER to the return value of toInt(), or 0 if str1 is null
    val a = str1?.toInt() ?: 0

    println("Please enter another number:")
    val str2 = readLine() // this might return null

    // Elvis: Set b EITHER to the return value of toInt(), or 0 if str2 is null
    val b = str2?.toInt() ?: 0

    // Note how we can embed full expressions inside strings with $
    println("The sum of the two numbers is ${a+b}");
}
</pre>
</li>
<li>This example reads in two numbers as (nullable) strings, tries to
convert them to integers with the <em>toInt()</em> method, 
and prints the sum</li>
<li>Note how the safe-access operator is used to call <em>toInt()</em>
in case <em>str1</em> is null</li>
<li>What of the new operator, <em>?:</em> though?</li>
<li>This is known as the <em>Elvis operator</em> (why? apparently because it's 
the emoticon for Elvis Presley)</li>
<li>In cases where we're trying to call a method (or access an property) of a nullable with the safe-access operator, the Elvis operator allows us to set a value for a variable normally obtained from the return value of the method 
in cases where the nullable is null</li> 
<li>So if either string (str1 or str2) is null, the corresponding Int
(a or b) will be assigned the value 0 rather than the return value of
<em>toInt()</em></li>
<li>More on nullability <a href="http://kotlinlang.org/docs/reference/null-safety.html">here</a>.</li>
</ul>
-->
<h3>Functions in Kotlin</h3>
<ul>
<li>The following example shows the use of functions in Kotlin, 
including parameters and <em>return types</em>:
<pre>
fun printString(s: String, nTimes: Int)
    for(i in 1..nTimes) {
        print(s)
    }
    print("\n")
}

fun cube(number: Double) : Double {
    return number * number * number
}

fun main (args: Array&lt;String&gt;) {
    printString("*", 3)    
    printString("#", 4)    
    printString("!", 5)    
    println("The cube of 3 is: ${cube(3.0)}")
}
</pre>
</li>
<li>Note the syntax for parameters, in which we specify the <em>data type</em> of each parameter:
    <pre>fun printString<em>(s: String, nTimes: Int)</em></pre>
 and note how we specify the <em>return type</em> of the function: the type of data which is returned. 
    <pre>fun cube(number: Double) : <em>Double</em></pre>
</li>
<li>This illustrates the strongly-typed nature of Kotlin. We <em>must</em> pass in a string and an integer to the function; if we pass anything else the compiler will give an error. Similarly, we <em>must</em> return a double from the function.</li>
<li>Note also how we can put function calls in quotes using $, and {} to
contain the expression
    <ul><li> println("The cube of 3 is: <em>${cube(3.0)}</em>")</li></ul>
</li>
</ul>
<h2>Classes and Objects in Kotlin</h2>
<p>As this is an object-oriented programming module, we will now look at how to create <em>classes and objects</em> in Kotlin. Remember from last year that:
	<ul>
	<li>a <em>class</em> is a general blueprint, or specification, for what data an entity contains and how it operates (e.g. <code>Cat</code>);</li>
	<li>an <em>object</em> is a specific example of that class (e.g. a specific cat).</li>
	</ul>
Remember also that classes contain:
	<ul>
	<li><em>Properties</em>, also known as <em>attributes</em>, which <strong>describe</strong> objects of that class. For example, a cat class might have name, age and weight properties;</li>
	<li><em>Methods</em>, which describe what objects of that class can <em>do</em>. These are <em>functions within the class</em>. For example, a cat class might have <code>walk()</code>, <code>eat()</code> and <code>meow()</code> methods.	</li>
	</ul>
</p>
<h3>A Cat class</h3>
<p>
<img src="../images/cats_small.jpg" alt="Binnie and Clyde" />
<br />
Here is an example of a Kotlin class representing a Cat:
<br />
<pre>class Cat (nameIn: String, ageIn: Int, weightIn: Int) {

    // Properties (attributes)
    val name: String
    var age: Int
    var weight: Int
    
    // Init block, for performing tasks on creation of the object
    init {
        name = nameIn
        age = ageIn
        weight = weightIn
    }

    fun walk() {
        weight--
    }

    override fun toString() : String {
        return "Name: $name Age: $age Weight: $weight"
    }
}
</pre>
We could use this in a <code>main()</code> function as follows:
<pre>fun main (args: Array&lt;String&gt;) {
    val binnie = Cat("Binnie", 10, 10)
    val clyde = Cat("Clyde", 5, 5)
    binnie.walk()
    clyde.walk()
    println(binnie)
    println(clyde)
}</pre>
<ul>
<li>Note how we begin the class declaration:
<pre>fun Cat(nameIn: String, ageIn: String, weightIn: String)</pre>
This is known as the <strong>primary constructor</strong>. A
<em>constructor</em> is used to <em>initialise</em> objects of the current class. It is the equivalent of the initialisation method <code>__init__()</code> in Python.  The constructor takes <em>parameters</em> of the name (<code>nameIn</code>), age (<code>ageIn</code>) and weight (<code>weightIn</code>): these are passed into objects from outside the class.</li>
<li>Note how we <strong>place the constructor parameters (<code>nameIn</code>, <code>ageIn</code> and <code>weightIn</code>) immediately after the class name</strong> - this is different to Python in which we create the <code>__init__()</code>
function inside the class body</li>
<li>Note how we need to <em>declare the class properties (<code>name</code>, <code>age</code> and <code>weight</code>) inside the class</em>. We did not need to do this with Python.</li>
<li>Note also the <strong>init block</strong>. This contains code we want
to run when the object is first created. Here, we use the init block to set the 
properties equal to the constructor parameters</li>
<li>The <code>walk()</code> function is a class <em>method</em>, working the same way as methods in Python.</li>
<li>The <code>toString()</code> method returns a <em>string representation of our object</em>, containing the current Cat's name, age and weight. This is useful if we need to display the object. For example, when we print objects, such as our two Cats:
<pre>println(binnie)
println(clyde)</pre>
the <code>toString()</code> method is used to figure out how to display the object.
<br />
<br />
Note that we precede the <code>toString()</code> method with the keyword <code>override</code>. This explicitly states that we are overriding a method from the superclass, in other words replacing a more general version of the method in the superclass with a more specific version in a subclass. You might be thinking, what is the superclass? No inheritance is declared here. In fact, all Kotlin classes implicitly inherit from the <code>Object</code> class, which is the superclass of all others.</li>
<li>Note also that we specify the <em>return type</em> of <code>toString()</code>:
<pre>override fun toString() : <em>String</em></pre>
</li>
</ul>
<h4>Making our class more concise - automatically setting 
constructor parameters equal to class properties</h4>
<ul>
<li>This version of the previous example is considerably more concise:
<pre>class Cat (val name: String, var age: Int, var weight: Int) {

    fun walk() {
        weight--
    }

    fun toString() : String {
        return "Name: $name Age: $age Weight: $weight"
    }
}
</pre>
</pre>
</li>
<li>Note how we <em>specify either val or var before each constructor parameter</em>.  This <strong>automatically makes each parameter an property of the class
</strong></li>
<li><em>val</em>s will be immutable, <em>var</em>s will be mutable</li>
<li>Thus, unlike the previous version, we do not have to declare the
properties inside the class, or use an init block</li>
</ul>
<h4>Data classes - concisely representing complex data structures
</h4>
<ul>
<li>In many cases, we need to create classes which represent a complex data
structure, but do not need methods</li>
<li>A good example would be a <em>Point</em> class, to represent a 
2D point (with x and y coordinates)</li>
<li>In Java, you could do this (note how x and y are public, to avoid
the need for getters and setters; an implementation which wanted to
make x and y immutable would need to make them private and add getter methods):
<pre>public class Point {
    public int x, y;

    public Point (int x, int y) {
         this.x = x;
         this.y = y;
    }
}
</pre>
</li>
<li>However, having to create a constructor to initialise the properties
to the constructor parameters is a pain</li>
<li>In Kotlin, in an extension of the previous example,
you can create a Point class with just
<strong>one line of code</strong>:
<pre>data class Point(val x:Int, val y: Int)</pre>
</li>
<li>That is it! This will create a Point class, with a two argument
constructor (x and y), and two immutable (because of <em>val</em>) 
properties, also x and y</li>
<li>This could be used in a main() function as follows:
<pre>data class Point(val x:Int, val y: Int)

fun main (args: Array&lt;String&gt;) {
    val p = Point(0, 5)
    val p2 = Point(5, 2)
    println("${p.x} ${p.y}")
    println("${p2.x} ${p2.y}")
}
</pre>
</li>
<li>Much more concise code!</li>
</ul>
<h2>Exercises</h2>
<h3>1. Hello World.</h3>

<p>
We are going to be using IntelliJ IDEA. Create a new project in IDEA by selecting New Project. Ensure that you un-select "Add sample code"; this creates auto-generated code but we will be starting from scratch.
<br />
<br />
<img src="../images/ideaproject_create.png" alt="Creating an IDEA Kotlin project" />
<br />
<br />
The project will be initialised and you will end up with an empty project, as follows: 
<br />
<br />
<img src="../images/ideaproject_empty.png" alt="Empty IDEA project" />
<br />
<br />
You then need to add a new file to the project. Do this by right clicking on <code>src</code> and then selecting <em>New Kotlin Class/File</em>, as shown below:
<br />
<br />
<img src="../images/ideaproject_newkotlinfile.png" alt="Adding a new Kotlin file" />
<br />
<br />
Then select <em>File</em> (not <em>Class</em>) and choose a filename: <code>Main.kt</code> is standard.
<br />
<br />
<img src="../images/ideaproject_newkotlinfile2.png" alt="Adding a new Kotlin file - specifying filename" />
<br />
<br />
You will then end up with an editing area for your source code on the right of the screen, alongside the project structure. Add "hello world" there:
<br />
<br />
<img src="../images/ideaproject.png" alt="Adding Hello World code" />
<br />
<br />
Then, compile and run the Kotlin program by clicking on the green "Run" icon as shown above. The output will appear in the "Run" console output window at the bottom of the screen.
<br />
<br />
<img src="../images/ideaproject_run.png" alt="IDEA project: console output" />
</p> 

<h3>2. Loops and ifs – basic</h3>

<ul>
<li>Create a new program, ex2.kt. The program should ask the user to
input their name and then should print it 10 times.</li>
<li>Modify the program so that it also asks how many times they want to display
their name.</li>
</ul>




<h3>3. Using an array</h3>

<ul>
<li>
Create a new program which stores an array of your
favourite music artists.
The program should prompt the user to ask the user to input an artist
name. Use a loop to keep prompting the user until they guess one of the correct artists. Hint: you can use <code>while</code> with <code>in</code> to achieve this.

</li>
</ul>

<h3>4. when</h3>

<p>Write a program which uses a "when" statement to print the grade (A, B, C, D, E,
or F) equivalent to a given percentage. Make the 'when' act as an expression,
i.e. you should get it to return a value and then print that value.
Grades are as follows:
<pre>
A - 70-100
B - 60-69
C - 50-59
D - 40-49
E - 30-39
F – 0-29
</pre>

The program should also display "Error - invalid percentage" if the percentage is
below 0 or greater than 100.

Hint: you can use the "in" keyword with a range (e.g. 1..10) as a condition inside
"when".
</p>


<h3>5. Classes and objects, including using Git branching</h3>

<p>This exercise will also allow you to get some initial experience of Git <em>branching</em>.</p>
<p>Git repositories can contain multiple <em>branches</em>, all with the project code in a different state. Why is this important? The main branch of a repository (usually called <code>main</code> or <code>master</code>) represents stable, well-tested code which is production-ready: ready for people to use. Commits to the main branch would normally just be bug-fixes. However, frequently developers wish to add new and experimental features to a project which require extensive testing, and which might break the main branch and make the project unstable and unusable until such testing has been completed. For this reason, developers frequently create additional branches to add these new, experimental features. Often a separate branch for each feature (called a <em>feature branch</em>) is created. Each feature is tested in isolation. Once this has been done, a common strategy is then to <em>merge</em> each feature branch into a <em>development branch</em> (frequently called <code>dev</code>) which will contain all new and experimental features. This can be further tested before similarly <em>merging</em> the code to the main branch.</p>
<p>This typical branching workflow is shown below:
<br />
<img src="../images/typical_branch_workflow.png" alt="Typical Git branching workflow" />
</p>
<p>Another use of branches, and one which you will make use of in the Group Project, is to allow multiple developers in a team to work independently on a project. Each team member can create their own branch and work on their assigned features independently, without breaking the main branch. Again, individual team member branches can be merged into a dev branch and tested, and when all is working, the dev branch can be merged into the main branch.</p>
<p>A more detailed article on Git branching and merging is available on <a href="https://git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging">the Git website</a>. Git merging is a bit more complex than basic branching (due to the possibility of <em>conflicts</em>), so will be considered later in the module.</p>
<h4>Setting up a dev branch of the Cat project</h4>
<ul>
<li>Login to GitHub and make a <em>fork</em> of this repository containing the cat app above:
<pre>https://github.com/nwcourses/CatApp</pre>
</li>
<li>Clone your fork from Git Bash:
<pre>git clone https://github.com/yourusername/CatApp.git</pre>
</li>
<li>Create a separate <em>branch</em> called <code>dev</code>. This is a <code>dev</code> branch which will contain new features.
<pre>git checkout -b dev</pre>
</li>
<li>Open the project in IntelliJ IDEA.</li>
</ul>
<h4>Working on the Cat app, committing changes, and pushing to GitHub</h4>
<ul>
<li>Add an additional method to <code>Cat</code> called <code>eat()</code>. The <code>eat()</code> method should add one to the weight of the cat.</li>
<li>Make a commit from Git Bash (we will be using Git Bash to commit and push as it's simpler than via IDEA)</li.
<li>Extend the code in the <code>main()</code> to create two Cats with these attributes:
<pre>Name: Flathead Age:7 Weight:10
Name: Cupra Age:2 Weight:7</pre>
Make Flathead eat twice, and display Flathead's details. Make Cupra walk four times, and display Cupra's details.
</li>
<li>Again commit your changes.</li>
<li>Finally push your <code>dev</code> branch to GitHub. This will setup a remote <code>dev</code> branch on GitHub which will be separate from the <code>main</code> branch.</li>
</ul>
<h3>6. Another object-oriented app</h3>
<ul>
<li>Create a completely new project called <code>StudentApp</code> and add a class called <code>Student</code> to represent a student, as well as a <code>main()</code>.
Give it the following attributes:
	<ul>
	<li><code>id</code>, representing the student's ID (<code>String</code>)</li>
	<li><code>name</code>, representing the student's name (<code>String</code>)</li>
	<li><code>course</code>, representing the student's course. (<code>String</code>)</li>
	<li><code>mark</code>, the student's mark (<code>Double</code>).</li>
	</ul>
Also give it:
	<ul>
	<li>A constructor, which initialises the four attributes.</li>
	<li><code>toString()</code> should return the details of the student (name, course and mark).
	</ul>
</li>
<li>Add code to your <code>main()</code> to create a <code>Student</code> object each time the loop runs, using the details the user entered from the keyboard. Then, still within the loop, display each student.</li>
</ul>
</main>

</body></html>
