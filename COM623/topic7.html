<!DOCTYPE html>
<html lang="en"><head>
<title>Topic 7: Introduction to Server-side Rendering and Server Components</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel='stylesheet' type='text/css' href='https://code.cdn.mozilla.net/fonts/fira.css' >
<link rel="stylesheet" type="text/css" href="../css/nwnotes.css">
</head><body>

<header>
<h1>Topic 7: Introduction to Server-side Rendering and Server Components</h1>
</header>

<main>
<div class="content-public">

<h2>Server-side Rendering</h2>

<p>Traditionally, React has rendered on the client-side, in the browser. JavaScript code running in the browser receives React components from the server, parses them and renders them. Communication with the server takes place via AJAX requests, as we have seen, with the server typically sending back JSON which is then transformed into JSX on the client side. Such applications are generally known as <em>Single-Page Applications (SPAs)</em>, because all the functionality is contained within a single HTML page, even if the content changes when the user interacts with the applicatiom. This is the same approach that non-React AJAX applications take.</p>

<p>Even though SPAs have been perhaps the leading type of web application recently, there are some advantages to rendering the page <em>on the server</em> instead. For example, if all rendering is done on the server, the client need not download the React JavaScript library and browser loading times are faster because the browser is just loading HTML rather than having to parse JSX. It can also be better for Search Engine Optimisation (SEO) because HTML is easier to handle for search engines than JavaScript. (see <a href='https://www.digitalocean.com/community/tutorials/react-server-side-rendering'>the Digital Ocean article</a> which discusses these advantages).</p> 

<p>There are of course disadvantages of server-side rendering: for example many clients will potentially connect to a server, meaning that the server might have to render pages in response to many requests coming in from different clients. Thus, the server could potentially become overloaded to a greater extent than if it simply sends back JSON to clients for the server to deal with. However this can be mitigated by the server caching the HTML pages generated by parsing the JSX server side.</p>

<p>Nonetheless despite these disadvantages there has been a lot of interest in React server-side rendering in the last two years or so due to the advantages discussed above, and thus it is an important topic to cover.</p>

<h2>Server-side Rendering and React Server Components</h2>

<p>In React server-side terminology, there are two slightly different concepts: <em>server-side rendering</em> (SSR) and <em>React Server Components</em> (RSC).We will discuss each.</p>

<h3>Server-side rendering</h3>

<p>SSR is the simplest of the two concepts. It simply involves using the <code>react-dom/server</code> module (as opposed to the usual <code>react-dom/client</code> module) to render strings of JSX as HTML server-side. Here is a basic example of an Express server to do this.</p>
<pre>
import express from 'express';
import path from 'path';
import fs from 'fs/promises';

import React from 'react';
import ReactDOMServer from 'react-dom/server';
import App from '../src/components/app.mjs';

const PORT = 3000;

const app = express();

app.use(express.static('public'));

app.get('/', async(req, res) =&gt; {
    const app = ReactDOMServer.renderToString(&lt;App /&gt;);
    const indexFile = path.resolve('./html/index.html');
    try {
        const data = await fs.readFile(indexFile, 'utf8');
        res.send(
            data.replace("&lt;div id='root'&gt;&lt;/div&gt;", `&lt;div id="root"&gt;${app}&lt;/div&gt;`)
        );
    }catch(err) {
        res.status(500).send(err);
    }
});

app.listen(PORT, () =&gt; {
    console.log(`Server running on port ${PORT}.`);
});
</pre>
<p>Much of this is just standard Express but note the detail of the <code>/</code> route. Note how we use <code>ReactDOMServer.renderToString()</code> to render our <code>App</code> JSX component to pure HTML. We then load our <code>index.html</code> and read it into memory as a string with <code>fs.readFile()</code> from the <code>fs</code> (filesystem) package. We then replace the <code>root</code> div inside the HTML with a <code>root</code> div containing the HTML parsed from the JSX and send it back to the client.</p>
<h4>How do we run this server? It contains JSX!</h4>
<p>You might be wondering though: <strong>this server contains JSX (<code>&lt;App /&gt;</code>), so how will Node.js handle the JSX when it encounters it? Is it not a syntax error?</strong></p>
<p>The answer is: it is a syntax error, so we do not run this server directly with <code>node</code>. Instead we have to <em>transpile</em> it, for example with Babel. We could use Webpack to do this, here is an example of a Webpack config which will do it (<code>webpack.server.config.js</code>):
</p>
<pre>
const path = require('path');
const nodeExternals = require('webpack-node-externals');

module.exports = {
    mode: 'development',
    target: 'node',
    entry: './server/index.mjs',
    externals: [nodeExternals()],
    output: {
        path: path.resolve('server-build'),
        filename: 'index.js'
    },
    optimization: {
        minimize: false
    },
    module: {
        rules: [
            {
                test: /.(js|jsx|mjs)$/,
                use: {
                    loader: "babel-loader"
                }
            }
        ]
    }
}
</pre>
<p>Note how we specify our server (with JSX, as above) using the <code>entry</code> property and then define an output server in standard JavaScript (no JSX) in the <code>output</code> property. So the output server will be placed in the <code>server-build</code> folder. It's <em>this</em> server we run.</p>

<h3>The client</h3>
<p>The server will send back the output HTML but what if we want event handling, e.g. we want to handle events such as button clicks? How can we do this if it was rendered on the server, given that events are client side?</p>

<p>The answer is that we have to <em>hydrate</em> the HTML returned from the server. Here is an example of a client-side <code>index.jsx</code> which will do this:</p>
<pre>
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './components/app.mjs';

ReactDOM.hydrateRoot(document.getElementById('root'), &lt;App /&gt;);
</pre>
<p>Rather than <em>rendering</em> <code>App</code>, which we have already done server-side, we <em>hydrate</em> our React root instead. This means to convert it from static HTML (sent back from the server) to a "living" web page with event handling added. The <code>App</code> specified here is the <em>same</em> <code>App</code> that was rendered server-side (see above).</p>

<h3>Building the app</h3>
<p>We must use a bundler, such as Vite or Webpack, to both <em>transform the server from JSX to plain JavaScript</em> and <em>produce a client-side bundle to perform the hydration</em>. For example a <code>package.json</code> for an SSR project might include a <code>scripts</code> section like this:</p>
<pre>
{
  "name": "react-ssr",
  "version": "0.0.1",
  "scripts": {
    "build": "npx webpack; npx webpack --config webpack.server.config.js",
    "build-client": "npx webpack",
    "build-server": "npx webpack --config webpack.server.config.js",
    "start": "node server-build/index.js"
  },
  ...
}
</pre>
<p>Note the different build scripts:</p>
    <ul>
    <li><em>build</em> (<code>npm run build</code>) will build both the client side and server side;</li>
    <li><em>build-client</em> (<code>npm run build-client</code>) will build the client side;</li>
    <li><em>build-server</em> (<code>npm run build-server</code>) will build the server side;</li>
    <li><em>start</em> (<code>npm start</code>) will start the server.</li>
    </ul>
<p>Note that we will need <em>two</em> <code>webpack.config.js</code> files, one for the client and one for the server.</p>
<p>A full example is available <a href='https://github.com/nwcourses/react-ssr'>on GitHub.</a></p>


<h2>React Server Components</h2>
<p>React Server Components (RSC) are components which "render ahead of time, before bundling, in an environment separate from your client app or SSR Server" (see <a href='https://react.dev/reference/rsc/server-components'>React documentation</a>).
The idea is that code in Server Components are rendered <em>before</em> any bundling takes place, at build time. This allows them, for example, to read files or query a database on the machine where the bundling takes place. They can be used <strong>without a server running</strong>: in this case the build tool will download any dependencies before executing the code. As RSC code is run as part of the build process, its dependencies will not need to be included in the bundle sent to the client, minimising bundle size.</p>
<h3>Using RSC without a server, e.g. as a preprocessor</h3>
<p>Here is an example <strong>taken directly from the React documentation</strong> (it can be found <a href='https://react.dev/reference/rsc/server-components'>here</a>). Apologies for re-using the official React example rather than coming up with my own, but I think it perfectly illustrates React Server Components and why you might want to use them even if you are not running a server.</p>
<pre>
import marked from 'marked';
import sanitizeHtml from 'sanitize-html';
import fs from 'fs/promises';

async function Page({page}) {
    const content = await fs.readFile(`${page}.md`);
    return &lt;div&gt;{sanitizeHtml(marked(content))}&lt;/div&gt;;
}
</pre>
<p><code>marked</code> and <code>sanitizeHtml</code> are third-party libraries which would be installed by <code>npm</code> or another package manager. <code>marked</code> is used to convert Markdown to HTML, and <code>sanitizeHtml</code> processes the HTML to help prevent any cross-site scripting (XSS) attempts.</p>
<p>If we run this as an RSC, it will be run on the server (or more generally, the machine which does the bundling) meaning that only this machine need have <code>marked</code> and <code>sanitizeHtml</code> installed. We need not include these libraries in the bundle sent to the client.</p>.
<p>As the React documentation notes, this code need not be part of a web server. You can run it as a preprocessor on a machine to convert all your Markdown files to HTML and then upload the generated static HTML files to a server ready for users to view.</p>
<h3>Using RSC with a server</h3>
<p>We can, as the name might suggest, also run RSC as part of a <em>web server</em>. As discussed on the React documentation referenced above, server components can be rendered in response to the first request from the client, with the rendered components (i.e. the HTML output from the JSX rendered server-side) included in the bundle in addition to client-side components (which will contain JSX and be rendered on the client). An example might be a server component to render all pizzas available on a pizza-ordering website. The server component would query the database to find all the available pizzas, and then render that list of pizzas. The server component would output HTML and this HTML would then be sent to the client within the bundle, in addition to any client-side components needed.</p>
<p>It should be noted that RSC are distinct from SSR (Server Side Rendering). SSR simply involves using the <code>react-dom/server</code> package to render strings of JSX on the server-side to produce HTML. RSC on the other hand are entire components that are designed to be processed at the bundler stage when being built. Optionally, RSC can use SSR to render JSX strings as HTML while this bundling stage is taking place.</p>
<h3>Mixing server- and client-side components</h3>
<p>We might want to mix server-side and client-side components in the same application. Why might we want to do this? RSC cannot include any <em>interactivity</em>, such as allowing the user to fill in a form and click a button. In our pizza-ordering application, the user might wish to add a pizza to their basket by interacting with the application. This might involve the user entering a quantity and clicking a button.</p>
<p>What we'd do here is <em>mark client side components as client-side using the directive:</em></p>
<pre>"use client"</pre>
<p>If you are developing a system with a mix of both, the default is to assume server components. So anything without <code>use client</code> will be an RSC.</p>
<p>Here would be an RSC to render all pizzas. Note how each pizza is repesented by a &lt;PizzaOrder&gt; sub-component.</p>
<pre>
export default async function AllPizzas() {
    
    // Code to setup database not shown. This is just generic example code.
    const pizzas = await db.query("SELECT * FROM pizzas");

    const output = pizzas.map (pizza =&gt; 
        &lt;PizzaOrder pizza={pizza} /&gt;
    );
    return &lt;div&gt;{output}&lt;/div&gt;
}
</pre>
<p>Here is the <code>PizzaOrder</code> subcomponent:</p>
<pre>"use client"

export default function PizzaOrder({pizza}) {


    return &lt;div&gt;
        Pizza flavour: {pizza.flavour} &lt;br /&gt;
        Pizza price: {pizza.price} &lt;br /&gt;
        &lt;button onClick={order(pizza.id)}&gt;Order!&lt;/button&gt;
        &lt;/div&gt;

    function order(pizzaId) {
        // functionality to order the pizza (not shown)
        // This might involve sending an AJAX request to a server or even
        // using a Server Action (see later)
    } 
}</pre>
<p>Note how it uses interactivity. Thus we cannot make this a server component. However we can mark it with <code>use client</code> and <em>include it within a server component as a child</em>.</p>
<p>You should also note that you <em>cannot use effects or state in server components</em>, so if you want to use either, you must include them in a client component and then make the client component a child of your server component.</p>
<p>Note that client-side components within an RSC app can be processed in two different ways:</p>
    <ul>
    <li>The JSX can be sent back to the client to be rendered;</li>
    <li>The JSX can be processed server-side using SSR, and then sent back to the client to be <em>hydrated</em> (see SSR discussion, above).</li>
    </ul>

<h2>Implementation of React Server Components</h2>

<p>React does not provide an "official" implementation of a server to process RSC but leaves it up to third-party providers to implement. In this session, we will use one of the simplest and most accessible third-party providers, <code>@lazarv/react-server</code>, referred to from now on as <code><em>react-server</em></code>, created by Viktor Lázár. <code>react-server</code> includes an inbuilt, Node-based server which will process RSC; you do not have to create your own server.</p>

<h4>Use pnpm as your package manager</h4>
<p>When using <code>react-server</code>, it is recommended to use the package manager <code>pnpm</code>: using <code>npm</code> has some difficulties. You can install pnpm using npm:</p>
<pre>npm install -g pnpm</pre>
<p>or:</p>
<pre>npm install -g @pnpm/exe</pre>
<p>(see <a href="https://pnpm.io/installation#using=npm">the pnpm docs</a>).</p>
<p>On Windows you can also try the following from PowerShell (but note it might have problems):</p>
<pre>Invoke-WebRequest https://get.pnpm.io/install.ps1 -UseBasicParsing | Invoke-Expression</pre>
</div>
<p>You will need to install <code>react-server</code>:</p>
<pre>pnpm i @lazarv/react-server</pre>
<h4>Hello World with react-server</h4>
<pre>export default function App() {
    return &lt;div&gt;
        &lt;h1&gt;Hello React Server World!&lt;/h1&gt;
        &lt;/div&gt;;
}</pre>
<p>Note how this is <em>just a component</em>. However, you can run it directly using <code>react-server</code>: <code>react-server</code> will process it server side and output the HTML to the client.</p>
<pre>pnpm exec react-server ./App.jsx</pre>
<p>This will launch Vite and run the server in development mode, so that if you make changes, these are updated live. If all goes well you can access this via port 3000:</p>
<pre>http://localhost:3000</pre>
<p>If you View Source you will note that you see HTML, showing that the JSX was processed on the server and not the client.</p>
<h4>Building, and running in production mode</h4>
<p>As well as running <code>react-server</code> in dev mode, you can build bundles for production. If you do this, you then run the server in production mode. <code>react-server</code> uses Vite, so this technique should be familiar to you based on what we have already done with Vite.</p>
<p>So to build for production, we use:</p>
<pre>
pnpm exec react-server build ./App.jsx
</pre>
<p>and to run the server in production mode, we use:
<pre>
pnpm exec react-server start
</pre>

<h4>Including a client-side component</h4>

<p>To demonstrate the technique of including client components inside RSCs, we are now going to add a client-side component. Create this client-side component. It's just a test to show how client components can be embedded within server components; the familiar "count the clicks" example.</p>
<pre>"use client";

import { useState } from 'react';

export default function Clicker() {
    const [count, setCount] = useState(0);

    return &lt;div&gt;
        &lt;button onClick={() =&gt; setCount(count+1)}&gt;Click!&lt;/button&gt;
        You clicked {count} times.
        &lt;/div&gt;;
}</pre>
<p>Include <code>Clicker</code> within <code>App</code> as a child. Does the component appear?</p>
<p>If you do a View Source on the generated page, you will see the <em>full HTML</em> for the page. What does that tell you about how the JSX is processed?</p>
<p>Could this client component act as a server component instead?</p>
<h3>Server Actions</h3>
<p>Server-based React applications typically take a different approach to server-side functionality such as interacting with a database. Rather than APIs, RSCs query the database directly and generate JSX based on the contents of the database (as seen in the pizza example above). However what about <em>updates</em> on the server, i.e. updating the database in some way in response to a POST request? These are typically implemented using <em>server actions</em>.</p>
<p>Server actions are functions executed on the server typically in response to the user entering data in a form and then sending it to the server as a POST request. Rather than writing, for example, an Express POST route, we write our server functionality as a simple <em>function</em> and set our form's <em>action</em> to this function. An RSC environment then performs some behind-the-scenes magic on this code: under the hood it's still a standard HTTP POST request being processed by a server.</p>
<p>Server actions must be called by a <em>client component</em>. They must also be marked by the directive:</p>
<pre>"use server"</pre>
<p>to indicate that they run on the server.</p>
<h4>Client component communicating with a server action</h4>
<p>Here is an example client component which calls a server action:</p>
<pre>"use client";

import { addSong } from './actions/addsong.js';
import { useActionState } from 'react';

export default function AddSong() {

    const [ state, addSongWithState ]  = useActionState(addSong, { });
    return &lt;div&gt;
        &lt;form action={addSongWithState}&gt;
        &lt;h1&gt;Add Song&lt;/h1&gt;
        Title:&lt;br /&gt;
        &lt;input name='song' id='song' /&gt;&lt;br /&gt;
        Artist:
        &lt;input name='artist' id='artist' /&gt;&lt;br /&gt;
        Year:
        &lt;input name='year' id='year' type='number' /&gt;&lt;br /&gt;
        &lt;button type='submit'&gt;Go!&lt;/button&gt;
        &lt;/form&gt;
        State: { JSON.stringify(state) }
        &lt;/div&gt;;
}</pre>
<p>What's going on here?</p>
<ul>
<li>You'll notice that the component renders an HTML form to allow the user to add a song. Note how the form's <em>action</em> is <code>addSongWithState</code>, a <em>function</em>.</li>
<li>Where does this function come from? Note how we <em>import</em> <code>addSong</code> from <code>actions/addsong.js</code>. This is our server action, and we will look at it in detail later. However what we are also using here is using <em>action state</em>. Action state allows us to share state between client side components and server actions. However, to do this we need to convert our original server action <code>addSong</code> to a version which can use action state: <code>addSongWithState</code> here. To do this we use the React <code>useActionState()</code> hook:
<pre>const [ state, addSongWithState ]  = useActionState(addSong, { });</pre>
<code>useActionState()</code> takes two arguments: the original server action fuunction, and an object to represent the state (originally empty). It returns an array containing two members: a state variable (which will contain state returned from the server action), and a modified server action which will work with action state.</li>
<li>For the moment we display the state after the form using <code>JSON.stringify()</code> to convert it to JSON.</li>
</ul>
<h4>The server action</h4>
<p>Meanwhile, here is the actual server action:</p>
<pre>
"use server";

import Database from 'better-sqlite3';

export async function addSong(prevState, formData) {

    const title = formData.get("song"),
          artist = formData.get("artist"),
          year = formData.get("year");

    const db = new Database("wadsongs.db");

    const stmt = db.prepare("INSERT INTO wadsongs(title,artist,year) values(?,?,?)");
    const info = stmt.run(title, artist, year);
    return { info };
}
</pre>
<ul>
<li>Note how the server action is a function, as we've discussed above. It takes two parameters, <code>prevState</code> (the previous value of the action state), and <code>formData</code> (a FormData object, representing the form data: we looked at these last week with React Router actions).</li>
<li>Note how we read the form data and then perform an INSERT query on our SQLite database.</li>
<li>Note also how we <em>return</em> the information object returned from the server when we do the INSERT (this will contain the number of rows inserted (<code>changes</code>) and the ID of the row inserted (<code>lastInsertRowid</code>)). Critically, <strong>the return value of the server action becomes the action state</strong>. So, whatever is returned by the server action will become the <code>state</code> in the client component. As we display the <code>state</code> in our client, it follows that we will see the information returned from the database on the client as soon as the server action has completed.</li>
</ul>

<h2>Exercises</h2>
<ol>
<li>Add a new server-side component to display all songs in the HitTastic! database below all the other components and include it in your <code>App</code> component. Use the <code>wadsongs.db</code> from previous weeks.</li> 
<li>Adapt your "add song" server action so that it sends an error back within the JavaScript object if the title, artist, year are blank. On the client-side, test if this error has come back from the server action and if so, display it to the user in a user-friendly way. If not, obtain the insert ID from the JSON and inform the user that the song has been added with a particular ID (show the ID to them) in a user friendly way, e.g.
<pre>Song added with ID 1234</pre>
</li>
<li>Write a client-side <code>SearchForm</code> component. This should include a form to allow the user to search for an artist, and the artist should be stored in a state variable. The component should also display "You entered the artist " plus the artist that the user entered. It should also have a button: for now, just redirect the user to a <code>/search</code> route which you have not implemnented yet:
<pre>window.location = `/search/${artist}`;</pre>
</li>
</ol>

</main>
</body>
</html>
