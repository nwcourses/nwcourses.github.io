<!DOCTYPE html><html><head><link rel='stylesheet' type='text/css' href='../css/dfti0910.css' /></head><body><h1 id="week3implementingalinkedlist">Stacks</h1>
<div class='content-public'>
<h2 id="thestack">Introduction</h2>
<p>A stack data structure involves adding items from bottom to top, rather like a
stack of plates. When we remove items from the stack, we remove from the top,
again just like a stack of plates.
The stack is known as a "last in first out" or "LIFO" data structure.
It is called this, because the last things we add to the stack, are the
first things we remove. Here is an example of a simple stack of numbers.</p>
<p><img src="../images/stack.png" alt="Simple stack"></p>
<p>A stack can be used for any operation in which we need to navigate back to
a previous state. Examples could include:</p>
<ul>
<li><p>Browser navigation. When we visit a website, we often need to navigate back to a previous site. When we click the 'Back' button, we want to return to the site <em>immediately preceding</em> the one we are currently viewing. So when you click 'Back', the current site might be <em>removed from the stack</em> so that you return to the previous site.</p></li>
<li><p>Directory/folder structure. When navigating the folder system of your computer, you typically start at a 'root' folder (for example <code>C:\</code> on Windows, or your home directory on Linux) and then navigate to subfolders, for example <code>C:\Pictures</code>. You then might navigate to a sub-sub-folder, such as <code>C:\Pictures\Holiday</code> and then <code>C:\Pictures\Holiday\2018</code> and so on. In a subfolder you can navigate upwards to the previous folder, so that if you are in <code>C:\Pictures\Holiday</code> and you navigate upwards, you arrive at <code>C:\Pictures</code> and then <code>C:\</code> if you navigate upwards once more. So the process of navigating upwards <em>removes the current folder from the stack</em> and returns to the previous folder.</p></li>
<li><p>"Undo" commands in desktop applications. Each action you take in a desktop application might be stored on a stack, so that if you select "Undo", the topmost operation would be reversed, and then removed from the stack.</p></li>
</ul>
<p>(In actual fact, each of these is now implemented in a slightly more complex way, in the sense that you can, in modern browsers, move both back and forwards along your history, but we are assuming a more simplified implementation in which you can only move back for the purposes of illustrating a stack).</p>
<p>Another use of stacks, which you will appreciate more when you have done more programming, is:</p>
<ul>
<li>Storing function calls in a program.</li>
</ul>
<p>The two key operations of a stack, adding and removing items, have special
terms.</p>
<ul>
<li><p><strong>Push</strong>. To <em>push</em> an item onto a stack means to add it to the top.
It is possible the stack may only have a certain capacity, i.e. it can only hold
a certain number of items (perhaps due to memory constraints) in which case an error occurs if the stack is full.</p></li>
<li><p><strong>Pop</strong>. To <em>pop</em> an item off the stack means to remove it from the top.
The item is removed, and we also obtain it as a result of the pop operation.
If the stack is empty, an error is generated.</p></li>
</ul>
<p>An additional operation is:</p>
<ul>
<li><strong>Peek</strong>, To <em>peek</em> a stack is to obtain the value of the top-most item of the stack <em>without</em> removing it.</li>
</ul>
</div>


<div class='content-public'>
<h3>Paper Exercise 1.3 : Stacks</h3>
<p>We are now going to perform another paper-based exercise with stacks, to help
you understand them and their operations.</p>
<p>Imagine you have an empty stack. Draw the stack after each operation
below, and explain what, if anything is returned from each operation and
any errors that might occur.</p>

<p><code>push (a), push (b), pop (), push (c), peek (), pop (), pop (), pop (), push (d), push (e), push (f), pop (), push (g), push (h), peek (), push (i), pop (), pop (), pop (), peek ().</code></p>

</div>
<h2 id="implementingastackusingaclass">Implementing a Stack using a class</h2>
<p>Having looked at a simple <code>Cat</code> class in the object-oriented introduction topic, we are now going to do something a bit more practical and look at how we might create a <code>Stack</code> class.
Note that it does not actually act as
a stack at the moment, but it provides the framework for how a stack operates;
notice how it contains a list and <code>push()</code> and <code>pop()</code> methods.</p>
<pre><code class="python language-python">class Stack:
    def __init__(self):
        self.internalList = []

    def push(self, item):
        # Code to add an item to the stack will go here

        pass # ends the method when it's empty

    def pop(self):
        # Code to remove an item from the top of the stack will go here 

        pass # ends the method when it's empty

    def __str__(self):
        return self.internalList.__str__()
</code></pre>
<p>How is this working?</p>
<ul>
<li><p>Note how we define three methods again. We have <code>push()</code> and <code>pop()</code> to define the most fundamental operations of a stack. The <code>__init__()</code> method for a stack will, like the cat equivalent, run when the stack is first created. We are using it to create the underlying list associated with the stack (see below for more detail).</p></li>
<li><p>So, going back to <code>__init__()</code>, note how we are attaching an attribute <code>internalList</code> to the current object, with this code:</p></li>
</ul>
<pre><code class="python language-python">self.internalList = []
</code></pre>
<p>Note the <code>[]</code> syntax. This creates an empty list.</p>
<ul>
<li><p>Note how the <code>push()</code> method contains not just <code>self</code> but also another parameter, <code>item</code>. This is the item we want to add to the internal list.</p></li>
<li><p>Note the fourth method, <code>__str__()</code>. This is another special method, rather like <code>__init__()</code>. This is a method which defines <em>how objects of a class are printed</em>. We might want to print our stack with:</p></li>
</ul>
<pre><code class="python language-python">print(stack)
</code></pre>
<p>What happens though when we try to print an object? By default we just get its memory address. Adding a <code>__str__()</code> method to a class allows us to return a string representation which can be understood. Here, we return the string representation of the internal list, so when we print the stack, we see the contents of the internal list.</p>
<h3 id="exercise2">Exercise 1</h3>
<ol>
<li>In a separate module (e.g <code>stack.py</code>), write the <code>Stack</code> class as shown above, and try and complete the <code>push()</code> method of your <code>Stack</code> so that it takes the value passed to it, and appends it to the internal list. To do this you will need to use the list's <code>append()</code> method.
<pre><code class="python language-python">list1 = []
list1.append("John")
</code></pre>
</li>
<li>Test your <code>Stack</code> as follows by adding this code in a <code>main.py</code>: 
<pre><code class="python language-python">stack1 = Stack()
stack1.push(1)
stack1.push(4)
stack1.push(9)
print(stack1)
</code></pre>
</li>
<li>Write a <code>pop()</code> method. You can remove the final item from the internal list with:
<pre>del self.internalList[-1]</pre>
Note that <code>del</code> deletes an item from the list, and negative indices count from the <em>end</em> of the list (so -1 is the final element, -2 the second from last, and so on).
<br />
<br />
Does this work as you would expect a pop operation to? Test it by adding these lines to your test code (the code where you created the stack and pushed items
onto it), which pops the stack twice and prints the value returned from each <code>pop()</code> operation:</p>
<pre><code class="python language-python">popped1 = stack1.pop()
print(popped1)
popped2 = stack1.pop()
print(popped2)
</code></pre>
You will find it
does not. Why? <strong>Try and fix the code yourself to get it to work!</strong></li>
<li>Create a <em>second</em> Stack object in your test code, and this time, push these
items onto it:
<pre><code>Linux
Windows
Mac OS X
</code></pre>
Again, print the stack and pop items off the stack. Does it work with strings as well as integers?</li>
<li>You need to display an error if you pop an empty stack.
Using an <code>if</code> statement (you are doing these in COM411), display an error message in <code>pop()</code> if the stack is empty.
<br />
How can you tell whether the stack is empty?
</li>
<li>Create a <code>peek()</code> method for your Stack. Remember a <code>peek</code> operation should
return the top item of the stack <em>without</em> removing it.</li>
</ol>
<p><strong>Advanced optional exercise</strong>: If you are coping with this module and COM411 well so far, and keen to do more programming, and want something to do in your own time, read about <em>exceptions</em> and handle the error instead by <em>raising an exception</em>. This would be how errors are handled in real-world implementations of stacks. Feel free to implement your stack using exceptions and send it to me for checking.</p>
</body>
</html>
